{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "main.js",
    "src/ActionQueue.js",
    "src/Animator.js",
    "src/BoundingBox.js",
    "src/Component.js",
    "src/Graph.js",
    "src/GreulerAdapter.js",
    "src/Logger.js",
    "src/ModeSwitch.js",
    "src/ResetButton.js",
    "src/UrlState.js",
    "src/colors.js",
    "src/graphelements.js",
    "src/utils.js"
  ],
  "names": [],
  "mappings": "AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var greuler = global.greuler;\nvar GreulerAdapter = require('./src/GreulerAdapter');\nvar Graph = require('./src/Graph');\nvar Animator = require('./src/Animator');\nvar UrlState = require('./src/UrlState');\nvar ActionQueue = require('./src/ActionQueue');\nvar ResetButton = require('./src/ResetButton');\n\nrequire('./src/Logger').level = global.logLevel;\n\nvar actionQueue = new ActionQueue();\n\nvar horizontalPadding = 20;\nvar width = Math.floor(((window.innerWidth > 0) ? window.innerWidth : screen.width) - (2 * horizontalPadding));\nvar height = Math.floor(( 3/4 ) * ((window.innerHeight > 0) ? window.innerHeight : screen.height));\nvar nodeSize;\nvar edgeDistance;\n\nif (width < 1000) {\n  nodeSize = Math.floor(Math.min(width, height) * (1/18));\n  edgeDistance = 200;\n}\n\nglobal.adapter = new GreulerAdapter(greuler);\nglobal.graph = new Graph(\n  {\n    actionQueue: actionQueue,\n    adapter: adapter,\n    animator: new Animator({ actionQueue: actionQueue }),\n    state: new UrlState({\n      baseUrl: window.location.protocol + \"//\" + window.location.host + window.location.pathname,\n      setUrl: window.history.replaceState.bind(window.history, {}, ''),\n      urlSearchParams: new URLSearchParams(window.location.search),\n    }),\n    width: width,\n    height: height,\n    nodeSize: nodeSize,\n    edgeDistance: edgeDistance,\n    nodeAreaFuzzFactor: 0.1,\n    editModeAlternateInterval: 250,\n  });\n\nglobal.resetButton = new ResetButton({\n  actionQueue: actionQueue,\n  resettables: [\n    global.graph,\n  ],\n});\n\nglobal.graph.attachTo(document.getElementById('main-graph'));\nglobal.resetButton.attachTo(document.getElementById('reset-button'));\n",
    "function ActionQueue(options) {\n  this.setTimeout = (options && options.setTimeout) || global.setTimeout.bind(global);\n  this.clearTimeout = (options && options.clearTimeout) || global.clearTimeout.bind(global);\n}\n\nActionQueue.prototype = {\n  defer: function(timeout, fn) {\n    if (arguments.length == 1) {\n      fn = timeout;\n      timeout = 1;\n    }\n    var timeoutId = this.setTimeout(fn, timeout);\n    return {\n      cancel: (function() {\n        this.clearTimeout(timeoutId);\n      }).bind(this),\n    };\n  },\n\n};\n\nmodule.exports = ActionQueue;\n",
    "function Animator(options) {\n  this.actionQueue = (options && options.actionQueue);\n}\n\nAnimator.prototype = {\n  alternate: function() {\n    this._checkDependencies();\n    return new AlternatingAnimation(this.actionQueue, Array.prototype.slice.call(arguments));\n  },\n\n  _checkDependencies: function() {\n    if (!this.actionQueue) {\n      throw Error('ActionQueue is required');\n    }\n  },\n};\n\nfunction AlternatingAnimation(actionQueue, functions) {\n  this.actionQueue = actionQueue;\n  this.functions = functions;\n  this.currentIndex = 0;\n  this.interval = 100;\n  this.predicate = function() { return true; };\n}\n\nAlternatingAnimation.prototype = {\n  every: function(interval) {\n    this.interval = interval;\n    return this;\n  },\n\n  asLongAs: function(predicate) {\n    this.predicate = predicate;\n    return this;\n  },\n\n  play: function() {\n    var execute = (function() {\n      if (this.predicate()) {\n        this.functions[this.currentIndex]();\n        this.currentIndex = (this.currentIndex + 1) % this.functions.length;\n        this.actionQueue.defer(this.interval, execute);\n      }\n    }).bind(this);\n    execute();\n  },\n};\n\nmodule.exports = Animator;\n",
    "function BoundingBox(dimensions) {\n  this.dimensions = dimensions;\n}\n\nBoundingBox.prototype = {\n\n  expandBy: function(factor) {\n    var width = this.dimensions.right - this.dimensions.left;\n    var height = this.dimensions.bottom - this.dimensions.top;\n    return new BoundingBox({\n      left: this.dimensions.left - width*factor,\n      right: this.dimensions.right + width*factor,\n      top: this.dimensions.top - height*factor,\n      bottom: this.dimensions.bottom + width*factor,\n    });\n  },\n\n  translate: function(vector) {\n    return new BoundingBox({\n      left: this.dimensions.left + vector.x,\n      right: this.dimensions.right + vector.x,\n      top: this.dimensions.top + vector.y,\n      bottom: this.dimensions.bottom + vector.y,\n    });\n  },\n\n  contains: function(point) {\n    return this.dimensions.left <= point.x && point.x <= this.dimensions.right &&\n           this.dimensions.top <= point.y && point.y <= this.dimensions.bottom;\n\n  },\n\n};\n\nmodule.exports = BoundingBox;\n",
    "var utils = require('./utils');\nvar ModeSwitch = require('./ModeSwitch');\nvar LOG = require('./Logger');\n\n/**\n * Component constructor\n *\n * options - service objects\n * options - options for the component.\n *         - holdTime - amount of time to wait before triggering a \"hold\" event\n */\nfunction Component(options) {\n  if (options) {\n    this.actionQueue = options.actionQueue;\n    this.holdTime = options.holdTime || 250;\n    this.mouseTouchSwitch = new ModeSwitch({\n      actionQueue: this.actionQueue,\n      timeout: 500,\n    });\n  }\n\n  this.mouseDownCount = 0;\n  this.mouseUpCount = 0;\n  this.isInClickAndHold = false;\n}\n\nComponent.prototype = {\n  handleClick: function() {},\n  handleClickAndHold: function() {},\n\n\n  attachTo: function(targetElement) {\n    this._validateOptions();\n    var lastDownEvent = null;\n\n    targetElement.addEventListener('mouseup', (function(event) {\n      LOG.debug('mouseup', utils.normalizeEvent(event));\n      this.mouseTouchSwitch.exit('mouse', (function() {\n        this._handleMouseUp(lastDownEvent);\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('touchend', (function(event) {\n      LOG.debug('touchend', utils.normalizeEvent(event));\n      this.mouseTouchSwitch.exit('touch', (function() {\n        this._handleMouseUp(lastDownEvent);\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('mousedown', (function(event) {\n      event = utils.normalizeEvent(event);\n      LOG.debug('mousedown', event);\n      this.mouseTouchSwitch.enter('mouse', (function() {\n        lastDownEvent = event;\n        this._handleMouseDown(event);\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('touchstart', (function(event) {\n      event - utils.normalizeEvent(event);\n      LOG.debug('touchstart', event);\n      this.mouseTouchSwitch.enter('touch', (function() {\n        lastDownEvent = event;\n        this._handleMouseDown(event);\n      }).bind(this));\n    }).bind(this));\n\n    this.doAttach(targetElement);\n  },\n\n  /**\n   * Sub-components should override to initialize on attachment\n   */\n  doAttach: function(element) {\n\n  },\n\n  _validateOptions: function() {\n    if (!this.actionQueue) {\n      throw Error('actionQueue is required');\n    }\n  },\n\n  _handleMouseUp: function(event) {\n    this.mouseUpCount++;\n    if (this.isInClickAndHold) {\n      this.isInClickAndHold = false;\n    } else {\n      this.handleClick(event);\n    }\n  },\n\n  _handleMouseDown: function(event) {\n    this.mouseDownCount++;\n    var originalCount = this.mouseDownCount;\n\n    this.actionQueue.defer(this.holdTime, (function() {\n      if (this.mouseDownCount === originalCount &&\n          this.mouseUpCount === this.mouseDownCount - 1) {\n        this.isInClickAndHold = true;\n        this.handleClickAndHold(event);\n      }\n    }).bind(this));\n  },\n};\n\nmodule.exports = Component;\n",
    "var Component = require('./Component');\nvar colors = require('./colors');\nvar utils = require('./utils');\nvar LOG = require('./Logger');\n\nvar COLOR_ORDER = [\n  colors.INDIGO,\n  colors.VIOLET,\n  colors.RED,\n  colors.ORANGE,\n  colors.YELLOW,\n  colors.GREEN,\n  colors.BLUE,\n];\n\nfunction Graph(options) {\n  Component.apply(this, arguments);\n  if (options) {\n    this.adapter = options.adapter;\n    this.animator = options.animator;\n    this.state = options.state;\n    this.width = options.width;\n    this.height = options.height;\n    this.nodeSize = options.nodeSize;\n    this.edgeDistance = options.edgeDistance;\n    this.nodeAreaFuzzFactor = options.nodeAreaFuzzFactor;\n    this.editModeAlternateInterval = options.editModeAlternateInterval || 100;\n  }\n  this._setInitialState();\n}\n\n\nGraph.prototype = Object.assign(new Component(), {\n  doAttach: function(targetElement) {\n    this.adapter.initialize(\n      targetElement,\n      utils.optional({\n        width: this.width,\n        height: this.height,\n        nodes: this.state.retrievePersistedNodes().map((function(n) {\n          return utils.optional({\n            id: n.id,\n            color: n.color || COLOR_ORDER[0],\n            label: '',\n            size: this.nodeSize,\n          }, { force: ['id', 'label'] });\n        }).bind(this)),\n        edges: this.state.retrievePersistedEdges(),\n        edgeDistance: this.edgeDistance,\n      })\n    );\n  },\n\n  handleClick: function(event) {\n    var clickTarget = this.adapter.getClickTarget(\n      event, this.nodeAreaFuzzFactor\n    );\n\n    if (this._isInEditMode()) {\n      if (clickTarget.isNode() &&\n          clickTarget.id !== this.currentlyEditedNode.id) {\n        this.adapter.addEdge({\n          source: this.currentlyEditedNode,\n          target: clickTarget,\n          distance: this.edgeDistance,\n        });\n        this.state.persistEdge(this.currentlyEditedNode.id, clickTarget.id);\n      } else {\n        this._exitEditMode();\n      }\n    } else {\n      if (clickTarget.isNode()) {\n        this._setNextColor(clickTarget);\n      } else {\n        this._createNode();\n      }\n    }\n  },\n\n  handleClickAndHold: function(event) {\n    if (!this._isInEditMode()) {\n      var clickTarget = this.adapter.getClickTarget(\n        event, this.nodeAreaFuzzFactor\n      );\n      if (clickTarget.isNode()) {\n        this._enterEditMode(clickTarget);\n      }\n    }\n  },\n\n  reset: function() {\n    this.adapter.performInBulk((function() {\n      this.state.retrievePersistedNodes().forEach((function(node) {\n        this.adapter.removeNode(node);\n      }).bind(this));\n\n      this.state.retrievePersistedNodes().forEach((function(node) {\n        this.adapter.removeNode(node);\n      }).bind(this));\n\n    }).bind(this));\n\n    this._setInitialState();\n    this.state.reset();\n  },\n\n  _setNextColor: function(node) {\n    var colorIndex = this._getNextColorIndex(node.id);\n    var newColor = COLOR_ORDER[colorIndex];\n    this.adapter.setNodeColor(node, newColor);\n    this.colors[node.id] = colorIndex;\n    this.state.persistNodeColor(node.id, newColor);\n  },\n\n  _createNode: function() {\n    var nodeId = this.state.persistNode({\n      color: COLOR_ORDER[0],\n    });\n    var node = utils.optional({\n      id: nodeId,\n      color: COLOR_ORDER[0],\n      label: '',\n      size: this.nodeSize,\n    }, { force: ['id', 'label'] });\n    this.adapter.addNode(node);\n  },\n\n  _getNextColorIndex: function(nodeId) {\n    var colorIndex = this.colors[nodeId] || 0;\n    return (colorIndex + 1) % COLOR_ORDER.length;\n  },\n\n  _isInEditMode: function() {\n    return !!this.currentlyEditedNode;\n  },\n\n  _enterEditMode: function(node) {\n    if (!this.animator) {\n      throw new Error('adapter is not present');\n    }\n    this.currentlyEditedNode = node;\n\n    this.editModeOtherNodes = this.adapter.getNodes(function(n) {\n      return n.id !== node.id;\n    });\n\n    this.animator\n      .alternate(\n        this._setNeon.bind(this),\n        this._setOriginalColor.bind(this)\n      )\n      .every(this.editModeAlternateInterval)\n      .asLongAs(this._isInEditMode.bind(this))\n      .play();\n  },\n\n  _exitEditMode: function() {\n    this.currentlyEditedNode = null;\n    this._setOriginalColor();\n    this.editModeOriginalColors = {};\n  },\n\n  _validateOptions: function() {\n    Component.prototype._validateOptions.call(this, arguments);\n    if (!this.adapter) {\n      throw new Error('adapter is not present');\n    }\n    if (!this.animator) {\n      throw new Error('animator is not present');\n    }\n    if (!this.state) {\n      throw new Error('state is not present');\n    }\n  },\n\n  _setNeon: function() {\n    this.editModeOtherNodes.forEach((function(n) {\n      if (!this.editModeOriginalColors[n.id]) {\n        this.editModeOriginalColors[n.id] = n.color;\n      }\n      this.adapter.setNodeColor(n, colors.NEON);\n    }).bind(this));\n  },\n\n  _setOriginalColor: function() {\n    this.editModeOtherNodes.forEach((function(n) {\n      if (this.editModeOriginalColors[n.id]) {\n        this.adapter.setNodeColor(n, this.editModeOriginalColors[n.id]);\n      }\n    }).bind(this));\n  },\n\n  _setInitialState: function() {\n    this.colors = {};\n    this.currentlyEditedNode = null;\n    this.editModeOtherNodes = [];\n    this.editModeOriginalColors = {};\n  },\n});\n\nmodule.exports = Graph;\n",
    "var graphelements = require('./graphelements');;\nvar utils = require('./utils');\nvar BoundingBox = require('./BoundingBox');\nvar LOG = require('./Logger');\n\n\nfunction GreulerAdapter(greuler) {\n  this.greuler = greuler;\n  this.isInBulkOperation = false;\n}\n\n\nGreulerAdapter.prototype = {\n  initialize: function(targetNode, options) {\n    options = options || {};\n    this.instance = this.greuler(utils.optional({\n      target: '#' + targetNode.id,\n      width: options.width,\n      height: options.height,\n      data: utils.optional({\n        nodes: (options.nodes && options.nodes.map(this._translateNodeObj)),\n        links: options.edges,\n        linkDistance: options.edgeDistance && function() {\n          return options.edgeDistance;\n        },\n      }),\n    })).update();\n    this.graph = this.instance.graph;\n  },\n\n  addNode: function(node) {\n    var result = this.graph.addNode(this._translateNodeObj(node));\n    this._updateInstance();\n  },\n\n  removeNode: function(node) {\n    var result = this.graph.removeNode(this._translateNodeObj(node));\n    this._updateInstance();\n  },\n\n  addEdge: function(options) {\n    var result = this.graph.addEdge(utils.optional({\n      source: options.source.id,\n      target: options.target.id,\n      linkDistance: options.distance,\n    }, { force: ['source', 'target'] }));\n    this._updateInstance();\n  },\n\n  setNodeColor: function(target, color) {\n    if (target.domElement) {\n      target.domElement.setAttribute('fill', color);\n    } else if (target.id) {\n      var node = this.graph.getNode({ id: target.id });\n      this._getDomElement(node).setAttribute('fill', color);\n    } else {\n      LOG.error('Got unexpected target node', target);\n    }\n  },\n\n  getClickTarget: function(event, nodeAreaFuzzFactor) {\n    return this._getTargetNode(event, nodeAreaFuzzFactor) || graphelements.NONE;\n  },\n\n  getNodes: function(filter) {\n    filter = filter || function() { return true; };\n    return this.graph.getNodesByFn(filter).map((function(node) {\n      var domElement = this._getDomElement(node);\n      return new graphelements.Node({\n        id: node.id,\n        realNode: node,\n        domElement: domElement,\n        color: domElement.getAttribute('fill'),\n      });\n    }).bind(this));\n  },\n\n  performInBulk: function(actions) {\n    this.isInBulkOperation = true;\n    actions(this);\n    this.isInBulkOperation = false;\n    this._updateInstance();\n  },\n\n  _translateNodeObj: function(node) {\n    return utils.optional({\n      id: node.id,\n      fill: node.color,\n      label: node.label || '',\n      r: node.size,\n    }, { force: ['id', 'label'] });\n  },\n\n  _getDomElement: function(node) {\n    return this.instance.nodeGroup[0][0]\n      .childNodes[node.index]\n      .getElementsByTagName('circle')[0];\n  },\n\n  _getTargetNode: function(event, nodeAreaFuzzFactor) {\n    nodeAreaFuzzFactor = nodeAreaFuzzFactor || 0;\n    var graphElementBounds = this.instance.root[0][0].getBoundingClientRect();\n    var point = {\n      x: event.clientX,\n      y: event.clientY,\n    };\n    var matchingNodes = this.getNodes(function(node) {\n      return new BoundingBox({\n        left: node.bounds.x,\n        right: node.bounds.X,\n        top: node.bounds.y,\n        bottom: node.bounds.Y\n      })\n        .expandBy(nodeAreaFuzzFactor)\n        .translate({ x: graphElementBounds.left, y: graphElementBounds.top })\n        .contains(point);\n    });\n\n    if (matchingNodes && matchingNodes.length) {\n      matchingNodes.sort(function(a, b) {\n        var distanceToA = utils.distance(center(a.realNode), point);\n        var distanceToB = utils.distance(center(b.realNode), point);\n        return distanceToA - distanceToB;\n      });\n      return matchingNodes[0];\n    } else {\n      return undefined;\n    }\n  },\n\n  _updateInstance: function() {\n    if (!this.isInBulkOperation) {\n      this.instance = this.instance.update();\n    }\n  },\n};\n\n\nfunction center(node) {\n  var width = node.bounds.X - node.bounds.x;\n  var height = node.bounds.Y - node.bounds.y;\n  return {\n    x: node.bounds.x + (width / 2),\n    y: node.bounds.y + (height / 2),\n  };\n}\n\nmodule.exports = GreulerAdapter;\n",
    "var LEVEL_ORDER = [\n  'DEBUG',\n  'INFO',\n  'WARN',\n  'ERROR',\n];\n\nfunction Logger() {\n  this.level = 'WARN';\n}\n\nLogger.prototype = {\n  debug: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'DEBUG'].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  info: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'INFO'].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  warn: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'WARN'].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  error: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'ERROR'].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n\n  _log: function() {\n    var level = arguments[1];\n    if (LEVEL_ORDER.indexOf(level) >= LEVEL_ORDER.indexOf(this.level)) {\n      global.console.log.apply(global.console.log, arguments);\n    }\n  },\n};\n\n\nmodule.exports = new Logger();\n",
    "function ModeSwitch(options) {\n  if (options) {\n    this.actionQueue = options.actionQueue;\n    this.timeout = options.timeout || 1;\n  }\n  this.currentMode = null;\n  this.resetModeFuture = null;\n}\n\nModeSwitch.prototype = {\n  enter: function(mode, fn) {\n    this._validate();\n    if (this.isPermitted(mode)) {\n      (fn || function() {})();\n      this.currentMode = mode;\n      this._cancelModeReset();\n    }\n  },\n\n  exit: function(mode, fn) {\n    this._validate();\n    if(this.isActive(mode)) {\n      (fn || function() {})();\n      this._scheduleModeReset();\n    }\n  },\n\n  isPermitted: function(mode) {\n    return !this.currentMode || this.isActive(mode);\n  },\n\n  isActive: function(mode) {\n    return this.currentMode === mode;\n  },\n\n  _cancelModeReset: function() {\n    this.resetModeFuture && this.resetModeFuture.cancel();\n  },\n\n  _scheduleModeReset: function() {\n    this._cancelModeReset();\n    this.resetModeFuture = this.actionQueue.defer(this.timeout, (function() {\n      this.currentMode = null;\n    }).bind(this));\n  },\n\n  _validate: function() {\n    if(!this.actionQueue) {\n      throw new Error('action queue is required');\n    }\n  },\n};\n\nmodule.exports = ModeSwitch;\n",
    "var Component = require('./Component');\n\nfunction ResetButton(options) {\n  Component.apply(this, arguments);\n  if (options) {\n    this.resettables = options.resettables;\n  } else {\n    this.resettables = [];\n  }\n\n}\n\nResetButton.prototype = Object.assign(new Component(), {\n  handleClick: function(event) {\n    this.resettables.forEach(function(resettable) {\n      resettable.reset();\n    });\n  },\n});\n\nmodule.exports = ResetButton;\n",
    "var utils = require('./utils');\n\nNUM_NODES_PARAM = 'n'\nCOLOR_PARAM_PREFIX = 'c_';\nEDGE_PARAM_PREFIX = 'e_';\n\nfunction UrlState(options) {\n  this.baseUrl = (options && options.baseUrl);\n  this.setUrl = (options && options.setUrl);\n  this.urlSearchParams = (options && options.urlSearchParams);\n}\n\nUrlState.prototype = {\n  /**\n   * Perist a node and return its id\n   */\n  persistNode: function(options) {\n    var nodeId = this._getNumNodes();\n    this.urlSearchParams.set(NUM_NODES_PARAM, nodeId + 1);\n    this._persistState();\n    if (options && options.color) {\n      this.persistNodeColor(nodeId, options.color);\n    }\n\n    return nodeId;\n  },\n\n  persistNodeColor: function(nodeId, color) {\n    var bit = this._idToBit(nodeId);\n\n    this._getColorKeys().forEach((function(key) {\n      if (this._isColor({ bit: bit, colorKey: key })) {\n        this._removeColor({ bit: bit, colorKey: key });\n      }\n    }).bind(this));\n\n    this._setColor({ bit: bit, color: color });\n    this._persistState();\n  },\n\n  persistEdge: function(sourceId, targetId) {\n    var param = EDGE_PARAM_PREFIX + sourceId;\n    var bitmask;\n    if (this.urlSearchParams.has(param)) {\n      bitmask = this._getBitmaskParam(param) | this._idToBit(targetId);\n    } else {\n      bitmask = this._idToBit(targetId);\n    }\n    this._setBitmaskParam(param, bitmask);\n    this._persistState();\n  },\n\n  retrievePersistedNodes: function() {\n    var nodes = [];\n    if (this.urlSearchParams.has(NUM_NODES_PARAM)) {\n      var colorParams = this._getColorKeys();\n      for (var i = 0 ; i < this.urlSearchParams.get(NUM_NODES_PARAM); i++) {\n        var nodeBit = this._idToBit(i);\n        var nodeColor = colorParams.find((function(param) {\n          return this._isColor({ bit: nodeBit, colorKey: param });\n        }).bind(this));\n        nodes.push(utils.optional({\n          id: i,\n          color: (nodeColor && nodeColor.replace(COLOR_PARAM_PREFIX, '#')),\n        }, { force: 'id' }));\n      }\n    }\n    return nodes;\n  },\n\n  retrievePersistedEdges: function() {\n    return this._getEdgeKeys().map((function(key) {\n      var sourceId = parseInt(key.replace(EDGE_PARAM_PREFIX, ''));\n      var edges = [];\n      var bitmask = this._getBitmaskParam(key);\n      var maxId = bitmask.toString(2).length;\n      for (var targetId = 0; targetId < maxId; targetId++) {\n        var bit = this._idToBit(targetId);\n        if ((bitmask & bit) === bit) {\n          edges.push({ source: sourceId, target: targetId });\n        }\n      }\n      return edges;\n    }).bind(this))\n    .reduce(function(a, b) { return a.concat(b); }, []);\n  },\n\n  getUrl: function() {\n    return this.baseUrl + '?' + this.urlSearchParams.toString();\n  },\n\n  reset: function() {\n    this._getKeys().forEach((function(key) {\n      this.urlSearchParams.delete(key);\n    }).bind(this));\n    this._persistState();\n  },\n\n  _isColor: function(options) {\n    options = this._normalizeColorOptions(options);\n\n    if (this.urlSearchParams.has(options.colorKey)) {\n      return (this._getBitmaskParam(options.colorKey) & options.bit) === options.bit;\n    } else {\n      return false;\n    }\n  },\n\n  _setColor: function(options) {\n    options = this._normalizeColorOptions(options);\n    var bitmask;\n\n    if (this.urlSearchParams.has(options.colorKey)) {\n      bitmask = this._getBitmaskParam(options.colorKey) | options.bit;\n    } else {\n      bitmask = options.bit;\n    }\n    this._setBitmaskParam(options.colorKey, bitmask);\n  },\n\n  _removeColor: function(options) {\n    options = this._normalizeColorOptions(options);\n    if (!this.urlSearchParams.has(options.colorKey)) {\n      throw Error('Attempted to remove color ' + options.colorKey);\n    }\n    var bitmask = this._getBitmaskParam(options.colorKey) & (~options.bit);\n    if (bitmask === 0) {\n      this.urlSearchParams.delete(options.colorKey);\n    } else {\n      this._setBitmaskParam(options.colorKey, bitmask);\n    }\n  },\n\n  _getBitmaskParam: function(key) {\n    return parseInt(this.urlSearchParams.get(key), 16);\n  },\n\n  _setBitmaskParam: function(key, value) {\n    this.urlSearchParams.set(key, value.toString(16));\n  },\n\n  _idToBit: function(id) {\n    if (id <= 30) {\n      return 1 << id;\n    } else {\n      return Math.pow(2, id);\n    }\n  },\n\n  _normalizeColorOptions: function(options) {\n    if (!options.hasOwnProperty('bit') && !options.hasOwnProperty('nodeId')) {\n      throw Error('bit or nodeId is required');\n    }\n    if (!options.hasOwnProperty('color') && !options.hasOwnProperty('colorKey')) {\n      throw Error('color or colorKey is required');\n    }\n    var bit = options.hasOwnProperty('bit')\n      ? options.bit\n      : this._idToBit(options.nodeId);\n    var colorKey = options.hasOwnProperty('colorKey')\n      ? options.colorKey\n      : options.color.replace('#', COLOR_PARAM_PREFIX);\n    return { bit: bit, colorKey: colorKey };\n  },\n\n  _getColorKeys: function() {\n    return this._getKeys(function(k) {\n      return k.startsWith(COLOR_PARAM_PREFIX);\n    });\n  },\n\n  _getEdgeKeys: function() {\n    return this._getKeys(function(k) {\n      return k.startsWith(EDGE_PARAM_PREFIX);\n    });\n  },\n\n  _getKeys: function(predicate) {\n    predicate = predicate || function() { return true; };\n    var keys = [];\n    var iterator = this.urlSearchParams.keys();\n    var next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        keys.push(next.value);\n      }\n      next = iterator.next();\n    }\n    return keys;\n  },\n\n  _getNumNodes: function() {\n    if (this.urlSearchParams.has(NUM_NODES_PARAM)) {\n      return parseInt(this.urlSearchParams.get(NUM_NODES_PARAM));\n    } else {\n      return 0;\n    }\n  },\n\n  _persistState: function() {\n    this.setUrl(this.getUrl());\n  },\n};\n\nmodule.exports = UrlState;\n",
    "module.exports = {\n  RED: '#db190f',\n  ORANGE: '#f76402',\n  YELLOW: '#fbff14',\n  GREEN: '#28b92b',\n  BLUE: '#2826b5',\n  INDIGO: '#2980B9',\n  VIOLET: '#8c28b7',\n  NEON: '#00FF00',\n};\n",
    "function GraphElement(options) {\n  if (options) {\n    this.id = options.id;\n    this.domElement = options.domElement;\n  }\n}\n\nGraphElement.prototype = {\n  isNode: function() {\n    return false;\n  },\n  isEdge: function() {\n    return false;\n  },\n};\n\nfunction Node(options) {\n  GraphElement.apply(this, arguments);\n  if (options) {\n    this.realNode = options.realNode;\n    this.color = options.color;\n  }\n}\n\nNode.prototype = Object.assign(new GraphElement(), {\n  isNode: function() { return true; },\n});\n\n\nfunction Edge() {\n  GraphElement.apply(this, arguments);\n}\n\nEdge.prototype = Object.assign(new GraphElement(), {\n  isEdge: function() { return true; },\n});\n\nfunction None() {\n  GraphElement.apply(this, arguments);\n}\n\nNone.prototype = Object.assign(new GraphElement(), {\n\n});\n\nmodule.exports = {\n  Node: Node,\n  Edge: Edge,\n  NONE: new None(),\n};\n",
    "/**\n * Compute the cartesian distance between two vectors\n */\nfunction distance(point1, point2) {\n  var x = point1.x - point2.x;\n  var y = point1.y - point2.y;\n  return Math.sqrt(x*x + y*y);\n}\n\n/**\n * Construct an object that has all the key-values for which values\n * are present in the input.\n */\nfunction optional(keyValuePairs, options) {\n  var obj = {};\n  Object.keys(keyValuePairs).forEach(function(key) {\n    if (keyValuePairs[key]) {\n      obj[key] = keyValuePairs[key];\n    }\n  });\n  if (options && options.force) {\n    if (options.force.constructor === Array) {\n      options.force.forEach(function(key) {\n        obj[key] = keyValuePairs[key];\n      });\n    } else {\n      obj[options.force] = keyValuePairs[options.force];\n    }\n  }\n  return obj;\n}\n\n\nfunction normalizeEvent(event) {\n  if (event && event.touches && event.touches.length) {\n    return Object.assign(\n      event,\n      {\n        clientX: event.touches[0].clientX,\n        clientY: event.touches[0].clientY,\n        screenX: event.touches[0].screenX,\n        screenY: event.touches[0].screenY,\n      }\n    );\n  } else {\n    return event;\n  }\n}\n\nmodule.exports = {\n  distance: distance,\n  optional: optional,\n  normalizeEvent: normalizeEvent,\n};\n"
  ]
}