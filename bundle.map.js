{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "main.js",
    "src/Animator.js",
    "src/Component.js",
    "src/Graph.js",
    "src/GreulerAdapter.js",
    "src/Logger.js",
    "src/colors.js",
    "src/graphelements.js",
    "src/utils.js"
  ],
  "names": [],
  "mappings": "AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var greuler = global.greuler;\nvar GreulerAdapter = require('./src/GreulerAdapter');\nvar Graph = require('./src/Graph');\nvar Animator = require('./src/Animator');\n\nvar horizontalPadding = 20;\nvar width = Math.floor(((window.innerWidth > 0) ? window.innerWidth : screen.width) - (2 * horizontalPadding));\nvar height = Math.floor(( 3/4 ) * ((window.innerHeight > 0) ? window.innerHeight : screen.height));\nvar nodeSize;\n\nif (width < 700) {\n  nodeSize = Math.floor(Math.min(width, height) * (1/15));\n}\n\nglobal.adapter = new GreulerAdapter(greuler);\nglobal.graph = new Graph(\n  {\n    adapter: adapter,\n    animator: new Animator(),\n  },\n  {\n    width: width,\n    height: height,\n    nodeSize: nodeSize,\n    nodeAreaFuzzFactor: 0.1,\n    editModeAlternateInterval: 250,\n  });\n\nglobal.graph.attachTo(document.getElementById('main-graph'));\n",
    "function Animator(options) {\n  this.setTimeout = (options && options.setTimeout) || global.setTimeout.bind(global);\n}\n\nAnimator.prototype = {\n  alternate: function() {\n    return new AlternatingAnimation(this, Array.prototype.slice.call(arguments));\n  },\n};\n\nfunction AlternatingAnimation(animator, functions) {\n  this.animator = animator;\n  this.functions = functions;\n  this.currentIndex = 0;\n  this.interval = 100;\n  this.predicate = function() { return true; };\n}\n\nAlternatingAnimation.prototype = {\n  every: function(interval) {\n    this.interval = interval;\n    return this;\n  },\n\n  asLongAs: function(predicate) {\n    this.predicate = predicate;\n    return this;\n  },\n\n  play: function() {\n    var execute = (function() {\n      if (this.predicate()) {\n        this.functions[this.currentIndex]();\n        this.currentIndex = (this.currentIndex + 1) % this.functions.length;\n        this.animator.setTimeout(execute, this.interval);\n      }\n    }).bind(this);\n    execute();\n  },\n};\n\nmodule.exports = Animator;\n",
    "/**\n * Component constructor\n *\n * services - service objects\n * options - options for the component.\n *         - holdTime - amount of time to wait before triggering a \"hold\" event\n */\nfunction Component(services, options) {\n  this.setTimeout = (services && services.setTimeout) || global.setTimeout.bind(global);\n  this.holdTime = (options && options.holdTime) || 250;\n}\n\nComponent.prototype = {\n  handleClick: function() {},\n  handleClickAndHold: function() {},\n\n  mouseDownCount: 0,\n  mouseUpCount: 0,\n\n  attachTo: function(targetElement) {\n    targetElement.addEventListener('click', (function(event) {\n      this.handleClick(event);\n    }).bind(this));\n\n    targetElement.addEventListener('mouseup', (function(event) {\n      this.mouseUpCount++;\n    }).bind(this));\n\n    targetElement.addEventListener('mousedown', (function(event) {\n      this.mouseDownCount++;\n      var originalCount = this.mouseDownCount;\n\n      this.setTimeout((function() {\n        if (this.mouseDownCount === originalCount &&\n            this.mouseUpCount === this.mouseDownCount - 1) {\n          this.handleClickAndHold(event);\n        }\n      }).bind(this), this.holdTime);\n    }).bind(this));\n\n    this.doAttach(targetElement);\n  },\n\n  /**\n   * Sub-components should override to initialize on attachment\n   */\n  doAttach: function(element) {\n\n  },\n};\n\nmodule.exports = Component;\n",
    "var Component = require('./Component');\nvar colors = require('./colors');\nvar utils = require('./utils');\nvar LOG = require('./Logger');\n\nvar COLOR_ORDER = [\n  colors.INDIGO,\n  colors.VIOLET,\n  colors.RED,\n  colors.ORANGE,\n  colors.YELLOW,\n  colors.GREEN,\n  colors.BLUE,\n];\n\nfunction Graph(services, options) {\n  Component.apply(this, arguments);\n  this.adapter = (services && services.adapter);\n  this.animator = (services && services.animator);\n  this.nodes = [];\n  this.colors = {};\n  this.width = (options && options.width);\n  this.height = (options && options.height);\n  this.nodeSize = (options && options.nodeSize);\n  this.nodeAreaFuzzFactor = (options && options.nodeAreaFuzzFactor);\n  this.editModeAlternateInterval = (options && options.editModeAlternateInterval) || 100;\n\n  this.currentlyEditedNode = null;\n  this.editModeOtherNodes = [];\n  this.editModeOriginalColors = {};\n}\n\n\nGraph.prototype = Object.assign(new Component(), {\n  doAttach: function(targetElement) {\n    this._checkServices();\n    this.adapter.initialize(\n      targetElement,\n      utils.optional({ width: this.width, height: this.height })\n    );\n  },\n\n  handleClick: function(event) {\n    var clickTarget = this.adapter.getClickTarget(\n      event, this.nodeAreaFuzzFactor\n    );\n\n    if (this._isInEditMode()) {\n      if (clickTarget.isNode() &&\n          clickTarget.id !== this.currentlyEditedNode.id) {\n        this.adapter.addEdge(this.currentlyEditedNode, clickTarget);\n      }\n      this._exitEditMode();\n    } else {\n      if (clickTarget.isNode()) {\n        this._setNextColor(clickTarget);\n      } else {\n        this._createNode();\n      }\n    }\n  },\n\n  handleClickAndHold: function(event) {\n    if (!this._isInEditMode()) {\n      var clickTarget = this.adapter.getClickTarget(\n        event, this.nodeAreaFuzzFactor\n      );\n      if (clickTarget.isNode()) {\n        this._enterEditMode(clickTarget);\n      }\n    }\n  },\n\n  _setNextColor: function(node) {\n    var colorIndex = this._getNextColorIndex(node.id);\n    this.adapter.setNodeColor(node, COLOR_ORDER[colorIndex]);\n    this.colors[node.id] = colorIndex;\n  },\n\n  _createNode: function() {\n    var node = utils.optional({\n      id: this.nodes.length,\n      color: COLOR_ORDER[0],\n      label: '',\n      size: this.nodeSize,\n    }, { force: ['id', 'label'] });\n    this.nodes.push(node);\n    this.adapter.addNode(node);\n  },\n\n  _getNextColorIndex: function(nodeId) {\n    var colorIndex = this.colors[nodeId] || 0;\n    return (colorIndex + 1) % COLOR_ORDER.length;\n  },\n\n  _isInEditMode: function() {\n    return !!this.currentlyEditedNode;\n  },\n\n  _enterEditMode: function(node) {\n    if (!this.animator) {\n      throw new Error('adapter is not present');\n    }\n    this.currentlyEditedNode = node;\n\n    this.editModeOtherNodes = this.adapter.getNodes(function(n) {\n      return n.id !== node.id;\n    });\n\n    this.animator\n      .alternate(\n        this._setNeon.bind(this),\n        this._setOriginalColor.bind(this)\n      )\n      .every(this.editModeAlternateInterval)\n      .asLongAs(this._isInEditMode.bind(this))\n      .play();\n  },\n\n  _exitEditMode: function() {\n    this.currentlyEditedNode = null;\n    this._setOriginalColor();\n    this.editModeOriginalColors = {};\n  },\n\n  _checkServices: function() {\n    if (!this.adapter) {\n      throw new Error('adapter is not present');\n    }\n    if (!this.animator) {\n      throw new Error('animator is not present');\n    }\n  },\n\n  _setNeon: function() {\n    this.editModeOtherNodes.forEach((function(n) {\n      if (!this.editModeOriginalColors[n.id]) {\n        this.editModeOriginalColors[n.id] = n.color;\n      }\n      this.adapter.setNodeColor(n, colors.NEON);\n    }).bind(this));\n  },\n\n  _setOriginalColor: function() {\n    this.editModeOtherNodes.forEach((function(n) {\n      if (this.editModeOriginalColors[n.id]) {\n        this.adapter.setNodeColor(n, this.editModeOriginalColors[n.id]);\n      }\n    }).bind(this));\n  },\n});\n\nmodule.exports = Graph;\n",
    "var graphelements = require('./graphelements');;\nvar utils = require('./utils');\nvar LOG = require('./Logger');\n\n\nfunction GreulerAdapter(greuler) {\n  this.greuler = greuler;\n}\n\n\nGreulerAdapter.prototype = {\n  initialize: function(targetNode, options) {\n    this.instance = this.greuler(utils.optional({\n      target: '#' + targetNode.id,\n      width: (options && options.width),\n      height: (options && options.height),\n      r: (options && options.size),\n    })).update();\n    this.graph = this.instance.graph;\n  },\n\n  addNode: function(node) {\n    node = utils.optional({\n      id: node.id,\n      fill: node.color,\n      label: node.label || '',\n      r: node.size,\n    }, { force: ['id', 'label'] });\n    var result = this.graph.addNode(node);\n    this.instance = this.instance.update();\n  },\n\n  addEdge: function(node1, node2) {\n    var result = this.graph.addEdge(node1.id, node2.id);\n    this.instance = this.instance.update();\n  },\n\n  setNodeColor: function(target, color) {\n    if (target.domElement) {\n      target.domElement.setAttribute('fill', color);\n    } else if (target.id) {\n      var node = this.graph.getNode({ id: target.id });\n      this._getDomElement(node).setAttribute('fill', color);\n    } else {\n      LOG.error('Got unexpected target node', target);\n    }\n  },\n\n  getClickTarget: function(event, nodeAreaFuzzFactor) {\n    return this._getTargetNode(event, nodeAreaFuzzFactor) || graphelements.NONE;\n  },\n\n  getNodes: function(filter) {\n    filter = filter || function() { return true; };\n    return this.graph.getNodesByFn(filter).map((function(node) {\n      var domElement = this._getDomElement(node);\n      return new graphelements.Node({\n        id: node.id,\n        realNode: node,\n        domElement: domElement,\n        color: domElement.getAttribute('fill'),\n      });\n    }).bind(this));\n  },\n\n  _getDomElement: function(node) {\n    return this.instance.nodeGroup[0][0]\n      .childNodes[node.index]\n      .getElementsByTagName('circle')[0];\n  },\n\n  _getTargetNode: function(event, nodeAreaFuzzFactor) {\n    nodeAreaFuzzFactor = nodeAreaFuzzFactor || 0;\n    var x = event.clientX;\n    var y = event.clientY;\n    var matchingNodes = this.getNodes(function(node) {\n      var leftBound = node.x - (nodeAreaFuzzFactor * node.width);\n      var rightBound = node.x + (( 1+ nodeAreaFuzzFactor) * node.width);\n      var topBound = node.y - (nodeAreaFuzzFactor * node.height);\n      var bottomBound = node.y + ((1 + nodeAreaFuzzFactor) * node.height);\n      return leftBound <= x && x <= rightBound &&\n             topBound <= y && y <= bottomBound;\n    });\n\n    if (matchingNodes && matchingNodes.length) {\n      matchingNodes.sort(function(a, b) {\n        var distanceToA = utils.distance(center(a.realNode), [x, y]);\n        var distanceToB = utils.distance(center(b.realNode), [x, y]);\n        return distanceToA - distanceToB;\n      });\n      return matchingNodes[0];\n    } else {\n      return undefined;\n    }\n  }\n};\n\n\nfunction center(node) {\n    return [node.x + (node.width / 2), node.y + (node.height / 2)];\n}\n\nmodule.exports = GreulerAdapter;\n",
    "function Logger() {\n\n}\n\nLogger.prototype = {\n  debug: function(msg, objs) {\n    this._log.apply(this, ['DEBUG'] + arguments);\n  },\n  warn: function(msg, objs) {\n    this._log.apply(this, ['WARN'] + arguments);\n  },\n  error: function(msg, objs) {\n    this._log.apply(this, ['ERROR'] + arguments);\n  },\n\n  _log: function(level, msg) {\n    var objs = Array.prototype.splice.call(arguments, 1, arguments.length);\n    global.console.log('[' + level + '] ' + msg);\n    Array.prototype.forEach.call(objs, function(obj) { console.log(obj); });\n  },\n};\n\n\nmodule.exports = new Logger();\n",
    "module.exports = {\n  RED: '#db190f',\n  ORANGE: '#f76402',\n  YELLOW: '#fbff14',\n  GREEN: '#28b92b',\n  BLUE: '#2826b5',\n  INDIGO: '#2980B9',\n  VIOLET: '#8c28b7',\n  NEON: '#00FF00',\n};\n",
    "function GraphElement(options) {\n  if (options) {\n    this.id = options.id;\n    this.domElement = options.domElement;\n  }\n}\n\nGraphElement.prototype = {\n  isNode: function() {\n    return false;\n  },\n  isEdge: function() {\n    return false;\n  },\n};\n\nfunction Node(options) {\n  GraphElement.apply(this, arguments);\n  if (options) {\n    this.realNode = options.realNode;\n    this.color = options.color;\n  }\n}\n\nNode.prototype = Object.assign(new GraphElement(), {\n  isNode: function() { return true; },\n});\n\n\nfunction Edge() {\n  GraphElement.apply(this, arguments);\n}\n\nEdge.prototype = Object.assign(new GraphElement(), {\n  isEdge: function() { return true; },\n});\n\nfunction None() {\n  GraphElement.apply(this, arguments);\n}\n\nNone.prototype = Object.assign(new GraphElement(), {\n\n});\n\nmodule.exports = {\n  Node: Node,\n  Edge: Edge,\n  NONE: new None(),\n};\n",
    "/**\n * Compute the cartesian distance between two vectors\n */\nfunction distance(vec1, vec2) {\n  if (vec1.length != vec2.length) {\n    throw new Error(vec1.length + ' != ' + vec2.length);\n  }\n  return Math.sqrt(\n    vec1\n      .map(function(x, i) { return x - vec2[i]; })\n      .map(function(x) { return x * x; })\n      .reduce(function(a, b) { return a + b; })\n  );\n}\n\n/**\n * Construct an object that has all the key-values for which values\n * are present in the input.\n */\nfunction optional(keyValuePairs, options) {\n  var obj = {};\n  Object.keys(keyValuePairs).forEach(function(key) {\n    if (keyValuePairs[key]) {\n      obj[key] = keyValuePairs[key];\n    }\n  });\n  if (options && options.force) {\n    if (options.force.constructor === Array) {\n      options.force.forEach(function(key) {\n        obj[key] = keyValuePairs[key];\n      });\n    } else {\n      obj[options.force] = keyValuePairs[options.force];\n    }\n  }\n  return obj;\n}\n\nmodule.exports = {\n  distance: distance,\n  optional: optional,\n};\n"
  ]
}