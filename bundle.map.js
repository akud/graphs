{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "main.js",
    "src/ActionQueue.js",
    "src/Animator.js",
    "src/BlockText.js",
    "src/BoundingBox.js",
    "src/ColorChangingGraph.js",
    "src/Component.js",
    "src/ComponentManager.js",
    "src/DisallowedEditMode.js",
    "src/EditMode.js",
    "src/EditableLabel.js",
    "src/Graph.js",
    "src/GraphComponent.js",
    "src/GreulerAdapter.js",
    "src/ImmutableGraph.js",
    "src/Logger.js",
    "src/ModeSwitch.js",
    "src/NodeLabelSet.js",
    "src/Position.js",
    "src/ResetButton.js",
    "src/TextBox.js",
    "src/UrlState.js",
    "src/colors.js",
    "src/graphelements.js",
    "src/graphfactory.js",
    "src/utils.js"
  ],
  "names": [],
  "mappings": "AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var GreulerAdapter = require('./src/GreulerAdapter');\nvar UrlState = require('./src/UrlState');\nvar ActionQueue = require('./src/ActionQueue');\nvar ResetButton = require('./src/ResetButton');\nvar graphfactory = require('./src/graphfactory');\n\nrequire('./src/Logger').level = global.logLevel;\n\nvar actionQueue = new ActionQueue();\nvar urlSearchParams = new URLSearchParams(window.location.search);\nvar state = new UrlState({\n  baseUrl: window.location.protocol + \"//\" + window.location.host + window.location.pathname,\n  setUrl: window.history.replaceState.bind(window.history, {}, ''),\n  urlSearchParams: urlSearchParams,\n});\n\n\nvar horizontalPadding = 20;\nvar width = Math.floor(((window.innerWidth > 0) ? window.innerWidth : screen.width) - (2 * horizontalPadding));\nvar height = Math.floor(( 3/4 ) * ((window.innerHeight > 0) ? window.innerHeight : screen.height));\nvar nodeSize;\nvar edgeDistance;\n\nif (width < 1000) {\n  nodeSize = Math.floor(Math.min(width, height) * (1/18));\n  edgeDistance = 200;\n}\n\n\nglobal.graphComponent = graphfactory.newGraphComponent({\n  document: global.document,\n  adapter: new GreulerAdapter(global.greuler),\n  actionQueue: actionQueue,\n  state: state,\n  width: width,\n  height: height,\n  nodeAreaFuzzFactor: 0.1,\n  edgeDistance: edgeDistance,\n  alternateInterval: 250,\n  immutable: urlSearchParams.get('immutable') === 'true',\n  onlyChangeColors: urlSearchParams.get('onlyChangeColors') === 'true',\n  colorChoices: urlSearchParams.has('colorChoices') &&\n    urlSearchParams.getAll('colorChoices').map(function(c) { return '#' + c; }),\n  initialNodes: state.retrievePersistedNodes(),\n  initialEdges: state.retrievePersistedEdges(),\n});\n\nglobal.graph = global.graphComponent.graph;\n\nglobal.resetButton = new ResetButton(Object.assign({\n  resettables: [\n    global.graphComponent,\n  ],\n}, { actionQueue: actionQueue }));\n\nglobal.graphComponent.attachTo(document.getElementById('main-graph'));\nglobal.resetButton.attachTo(document.getElementById('reset-button'));\n",
    "function ActionQueue(options) {\n  this.setTimeout = (options && options.setTimeout) || global.setTimeout.bind(global);\n  this.clearTimeout = (options && options.clearTimeout) || global.clearTimeout.bind(global);\n  this.actionInterval = (options && options.actionInterval) || 10;\n  this.periodicActions = [];\n  this.hasStartedPeriodicActions = false;\n}\n\nActionQueue.prototype = {\n  defer: function(timeout, fn) {\n    if (arguments.length == 1) {\n      fn = timeout;\n      timeout = 1;\n    }\n    var timeoutId = this.setTimeout(fn, timeout);\n    return {\n      cancel: (function() {\n        this.clearTimeout(timeoutId);\n      }).bind(this),\n    };\n  },\n\n  periodically: function(fn) {\n    var periodicActions = this.periodicActions;\n    periodicActions.push(fn);\n\n    if(!this.hasStartedPeriodicActions) {\n      this._startPeriodicActions();\n    }\n\n    return {\n      cancel: function() {\n        periodicActions.splice(\n          periodicActions.indexOf(fn),\n          1\n        );\n      },\n    };\n  },\n\n  _startPeriodicActions: function() {\n      var queueFn = (function() {\n        this.periodicActions.forEach(function(fn) { fn(); });\n        this.setTimeout(queueFn, this.actionInterval);\n      }).bind(this);\n      queueFn();\n      this.hasStartedPeriodicActions = true;\n  },\n};\n\nmodule.exports = ActionQueue;\n",
    "function Animator(options) {\n  this.actionQueue = (options && options.actionQueue);\n}\n\nAnimator.prototype = {\n  alternate: function() {\n    this._checkDependencies();\n    return new AlternatingAnimation(this.actionQueue, Array.prototype.slice.call(arguments));\n  },\n\n  _checkDependencies: function() {\n    if (!this.actionQueue) {\n      throw Error('ActionQueue is required');\n    }\n  },\n};\n\nfunction AlternatingAnimation(actionQueue, functions) {\n  this.actionQueue = actionQueue;\n  this.functions = functions;\n  this.currentIndex = 0;\n  this.interval = 100;\n  this.predicate = function() { return true; };\n}\n\nAlternatingAnimation.prototype = {\n  every: function(interval) {\n    this.interval = interval;\n    return this;\n  },\n\n  asLongAs: function(predicate) {\n    this.predicate = predicate;\n    return this;\n  },\n\n  play: function() {\n    var execute = (function() {\n      if (this.predicate()) {\n        this.functions[this.currentIndex]();\n        this.currentIndex = (this.currentIndex + 1) % this.functions.length;\n        this.actionQueue.defer(this.interval, execute);\n      }\n    }).bind(this);\n    execute();\n    return this;\n  },\n\n  stop: function() {\n    return this.asLongAs(function() { return false; });\n  },\n};\n\nmodule.exports = Animator;\n",
    "var Component = require('./Component');\n\nfunction BlockText(opts) {\n  Component.apply(this, arguments);\n  this.text = opts && opts.text;\n}\n\nBlockText.prototype = Object.assign(new Component(), {\n  getGeneratedMarkup: function() {\n    return this.text && ('<p>'  + this.text + '</p>');\n  },\n});\n\nmodule.exports = BlockText;\n",
    "function BoundingBox(dimensions) {\n  this.dimensions = dimensions || {\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n  };\n}\n\nBoundingBox.prototype = {\n\n  expandBy: function(factor) {\n    return new BoundingBox({\n      left: this.dimensions.left - this.getWidth()*factor,\n      right: this.dimensions.right + this.getWidth()*factor,\n      top: this.dimensions.top - this.getHeight()*factor,\n      bottom: this.dimensions.bottom + this.getHeight()*factor,\n    });\n  },\n\n  translate: function(vector) {\n    return new BoundingBox({\n      left: this.dimensions.left + vector.x,\n      right: this.dimensions.right + vector.x,\n      top: this.dimensions.top + vector.y,\n      bottom: this.dimensions.bottom + vector.y,\n    });\n  },\n\n  contains: function(point) {\n    return this.dimensions.left <= point.x && point.x <= this.dimensions.right &&\n           this.dimensions.top <= point.y && point.y <= this.dimensions.bottom;\n\n  },\n\n  getCenter: function() {\n    return {\n      x: this.dimensions.left + this.getWidth() / 2,\n      y: this.dimensions.top + this.getHeight() / 2,\n    };\n  },\n\n  getTopLeft: function() {\n    return {\n      x: this.dimensions.left,\n      y: this.dimensions.top,\n    };\n  },\n\n\n  getTopRight: function() {\n    return {\n      x: this.dimensions.right,\n      y: this.dimensions.top,\n    };\n  },\n\n\n  getBottomLeft: function() {\n    return {\n      x: this.dimensions.left,\n      y: this.dimensions.bottom,\n    };\n  },\n\n  getBottomRight: function() {\n    return {\n      x: this.dimensions.right,\n      y: this.dimensions.bottom,\n    };\n  },\n\n  getWidth: function() {\n    return this.dimensions.right - this.dimensions.left;\n  },\n\n  getHeight: function() {\n    return this.dimensions.bottom - this.dimensions.top;\n  },\n\n};\n\nmodule.exports = BoundingBox;\n",
    "var Graph = require('./Graph');\n\nfunction ColorChangingGraph() {\n  Graph.apply(this, arguments);\n}\n\nColorChangingGraph.prototype = Object.assign(new Graph(), {\n\n  addNode: function() {},\n  addEdge: function() {},\n  reset: function() {},\n\n});\n\nmodule.exports = ColorChangingGraph;\n",
    "var utils = require('./utils');\nvar ModeSwitch = require('./ModeSwitch');\nvar Logger = require('./Logger');\nvar LOG = new Logger('Component');\n\n/**\n * Component constructor\n *\n * options - service objects\n * options - options for the component.\n *         - holdTime - amount of time to wait before triggering a \"hold\" event\n */\nfunction Component(options) {\n  if (options) {\n    this.actionQueue = options.actionQueue;\n    this.holdTime = options.holdTime || 250;\n    this.mouseTouchSwitch = new ModeSwitch({\n      actionQueue: this.actionQueue,\n      timeout: 500,\n      name: 'mouseTouchSwitch',\n    });\n  }\n\n  this.mouseDownCount = 0;\n  this.mouseUpCount = 0;\n  this.isInClickAndHold = false;\n  this.closeListeners = [];\n}\n\nComponent.prototype = {\n  handleClick: function() {},\n  handleClickAndHold: function() {},\n  handleEnter: function() {},\n\n  attachTo: function(targetElement) {\n    this._validateOptions();\n    this.element = targetElement;\n\n    targetElement.addEventListener('mouseup', (function(event) {\n      LOG.debug('mouseup', utils.normalizeEvent(event));\n      this.mouseTouchSwitch.exit('mouse', (function(modeState) {\n        this._handleMouseUp(modeState.lastDownEvent);\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('touchend', (function(event) {\n      LOG.debug('touchend', utils.normalizeEvent(event));\n      this.mouseTouchSwitch.exit('touch', (function(modeState) {\n        this._handleMouseUp(modeState.lastDownEvent);\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('mousedown', (function(event) {\n      event = utils.normalizeEvent(event);\n      LOG.debug('mousedown', event);\n      this.mouseTouchSwitch.enter('mouse', (function() {\n        this._handleMouseDown(event);\n        return { lastDownEvent: event };\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('touchstart', (function(event) {\n      event = utils.normalizeEvent(event);\n      LOG.debug('touchstart', event);\n      this.mouseTouchSwitch.enter('touch', (function() {\n        this._handleMouseDown(event);\n        return { lastDownEvent: event };\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('keyup', (function(event) {\n      event = utils.normalizeEvent(event);\n      LOG.debug('keyup', event);\n      if (event.keyCode === 13) {\n        this.handleEnter(event);\n      }\n    }).bind(this));\n\n    if (this.getGeneratedMarkup()) {\n      targetElement.innerHTML = this.getGeneratedMarkup();\n    }\n\n    this.doAttach(targetElement);\n  },\n\n  /**\n   * subclasses can override to indicate initial markup\n   * to be set on the target element\n   */\n  getGeneratedMarkup: function() {\n    return null;\n  },\n\n  /**\n   * Sub-components should override to initialize on attachment\n   */\n  doAttach: function(element) {\n\n  },\n\n  onRemove: function(listener) {\n    this.closeListeners.push(listener);\n    return this;\n  },\n\n  remove: function() {\n    this.closeListeners.forEach((function(f) {\n      f(this);\n    }).bind(this));\n    this.element.remove();\n    LOG.debug('closed component', this);\n  },\n\n  _validateOptions: function() {\n    if (!this.actionQueue) {\n      throw Error('actionQueue is required');\n    }\n  },\n\n  _handleMouseUp: function(event) {\n    this.mouseUpCount++;\n    if (this.isInClickAndHold) {\n      this.isInClickAndHold = false;\n    } else {\n      this.handleClick(event);\n    }\n  },\n\n  _handleMouseDown: function(event) {\n    this.mouseDownCount++;\n    var originalCount = this.mouseDownCount;\n\n    this.actionQueue.defer(this.holdTime, (function() {\n      if (this.mouseDownCount === originalCount &&\n          this.mouseUpCount === this.mouseDownCount - 1) {\n        this.isInClickAndHold = true;\n        this.handleClickAndHold(event);\n      }\n    }).bind(this));\n  },\n\n};\n\nmodule.exports = Component;\n",
    "var utils = require('./utils');\nvar Position = require('./Position');\nvar Component = require('./Component');\n\nfunction ComponentManager(options) {\n  this.document = options && options.document;\n  this.actionQueue = options && options.actionQueue;\n  this.componentServices = options && options.componentServices;\n}\n\nComponentManager.prototype = {\n  insertComponent: function(options) {\n    options = Object.assign({\n      position: new Position({ topLeft: { x: 0, y: 0 }}),\n      pinTo: undefined,\n      class: Component,\n      constructorArgs: undefined,\n    }, options);\n\n    var component = new options.class(Object.assign(\n      {},\n      this.componentServices,\n      options.constructorArgs\n    ));\n\n    var element = this.document.createElement('div');\n    if (options.position) {\n      element.style = options.position.getStyle();\n    }\n    if (typeof options.pinTo === 'function') {\n      var positionTracker = this.actionQueue.periodically((function() {\n        element.style = options.pinTo().getStyle({\n          width: element.offsetWidth,\n          height: element.offsetHeight,\n        });\n      }).bind(this));\n      component.onRemove(positionTracker.cancel.bind(positionTracker));\n    }\n    this.document.body.insertBefore(element, this.document.body.firstChild);\n    component.attachTo(element);\n    return component;\n  },\n};\n\nmodule.exports = ComponentManager;\n",
    "var EditMode = require('./EditMode');\n\nfunction DisallowedEditMode() {\n  EditMode.apply(this, arguments);\n}\n\nDisallowedEditMode.prototype = Object.assign(new EditMode(), {\n  activate: function() {},\n  _validate: function() {},\n});\n\nmodule.exports = DisallowedEditMode;\n",
    "var ModeSwitch = require('./ModeSwitch');\nvar colors = require('./colors');\nvar Logger = require('./Logger');\nvar LOG = new Logger('EditMode');\n\n\nfunction EditMode(opts) {\n  this.adapter = opts && opts.adapter;\n  this.animator = opts && opts.animator;\n  this.alternateInterval = (opts && opts.alternateInterval) || 250;\n  this.labelSet = opts && opts.labelSet;\n  this.modeSwitch = (opts && opts.modeSwitch) || new ModeSwitch({\n    name: 'editMode',\n  });\n  this.modeSwitch.enter('display');\n}\n\n\nEditMode.prototype = {\n\n  activate: function(node) {\n    LOG.info('activating');\n    this._validate();\n    this.modeSwitch\n      .exit('display')\n      .exit('edit', this._cleanUpEditState.bind(this))\n      .enter('edit', (function() {\n        var otherNodes = this.adapter.getNodes(function(n) {\n          return n.id !== node.id;\n        });\n        var originalColors = otherNodes.reduce(function(accum, node) {\n          accum[node.id] = node.color;\n          return accum;\n        }, {});\n\n        var animation = this.animator\n          .alternate(\n            this._setNeon.bind(this, otherNodes),\n            this._setOriginalColors.bind(this, otherNodes, originalColors)\n          )\n          .every(this.alternateInterval)\n          .play();\n\n        this.labelSet.edit(node);\n\n        var editState = {\n          node: node,\n          animation: animation,\n          otherNodes: otherNodes,\n          originalColors: originalColors,\n        };\n        LOG.debug('activated', editState);\n        return editState;\n      }).bind(this));\n  },\n\n  deactivate: function() {\n    LOG.debug('deactvating');\n    this._validate();\n    this.modeSwitch\n      .exit('edit', this._cleanUpEditState.bind(this))\n      .enter('display', function() {\n        LOG.debug('deactvated');\n      });\n  },\n\n  perform: function(opts) {\n    opts = Object.assign({\n      ifActive: function() {},\n      ifNotActive: function() {},\n    }, opts);\n    this._validate();\n\n    this.modeSwitch.ifActive({\n      edit: function(editState) { opts.ifActive(editState.node); },\n      display: opts.ifNotActive,\n    });\n  },\n\n  _setNeon: function(otherNodes) {\n    otherNodes.forEach((function(n) {\n      this.adapter.setNodeColor(n, colors.NEON);\n    }).bind(this));\n  },\n\n  _setOriginalColors: function(otherNodes, originalColors) {\n    otherNodes.forEach((function(n) {\n      this.adapter.setNodeColor(n, originalColors[n.id]);\n    }).bind(this));\n  },\n\n  _cleanUpEditState: function(editState) {\n    LOG.debug('cleaning up edit mode state', editState);\n    editState.animation.stop();\n    this.labelSet.display(editState.node);\n    this._setOriginalColors(editState.otherNodes, editState.originalColors);\n  },\n\n  _validate: function() {\n    if (!this.adapter) {\n      throw new Error('adapter is required');\n    }\n    if (!this.animator) {\n      throw new Error('animator is required');\n    }\n    if (!this.modeSwitch) {\n      throw new Error('modeSwitch is required');\n    }\n  }\n\n};\n\nmodule.exports = EditMode;\n",
    "var ModeSwitch = require('./ModeSwitch');\nvar BlockText = require('./BlockText');\nvar TextBox = require('./TextBox');\nvar Logger = require('./Logger');\nvar LOG = new Logger('EditableLabel');\n\nfunction EditableLabel(opts) {\n  if (opts) {\n    this.componentManager = opts.componentManager;\n    this.text = opts.text;\n    this.pinTo = opts.pinTo;\n    this.modeSwitch = new ModeSwitch({\n      name: 'EditableLabel({ text: \\'' + this.text + '\\'})'\n    });\n    this.onChange = opts.onChange || function() {};\n  }\n}\n\nEditableLabel.prototype = {\n  display: function() {\n    LOG.debug('displaying text', this.text);\n    this._validate();\n\n    this.modeSwitch.exit('edit', (function(editState) {\n      this.text = editState.component.getText();\n      editState.component.remove();\n      LOG.debug('got text from input component', this.text);\n    }).bind(this))\n    .exit('display', function(displayState) { displayState.component.remove(); });\n\n    if (this.text) {\n      this.modeSwitch.enter('display', (function() {\n        var component = this.componentManager.insertComponent({\n          class: BlockText,\n          constructorArgs: { text: this.text },\n          pinTo: this.pinTo,\n        });\n        this.onChange(this.text);\n        LOG.debug('EditableLabel: displaying component with text', this.text);\n        return { component: component };\n      }).bind(this));\n    }\n    return this;\n  },\n\n  edit: function() {\n    LOG.debug('editing text', this.text);\n    this._validate();\n    this.modeSwitch.exit('display', (function(displayState) {\n      displayState.component.remove();\n      LOG.debug('closed display component');\n    }).bind(this))\n    .exit('edit', function(editState) { editState.component.remove(); });\n\n    this.modeSwitch.enter('edit', (function() {\n       var component = this.componentManager.insertComponent({\n        class: TextBox,\n        constructorArgs: {\n          text: this.text,\n          onSave: this.display.bind(this),\n        },\n        pinTo: this.pinTo,\n      });\n      LOG.debug('opened edit component');\n      return { component: component };\n    }).bind(this));\n    return this;\n  },\n\n  _validate: function() {\n    if(!this.componentManager) {\n      throw new Error('componentManager is required');\n    }\n    if(!this.modeSwitch) {\n      throw new Error('modeSwitch is required');\n    }\n  },\n\n  remove: function() {\n    this.modeSwitch\n      .exit('display', function(displayState) { displayState.component.remove(); })\n      .exit('edit', function(editState) { editState.component.remove(); }) ;\n    return this;\n  },\n\n  _closeComponent: function(state) {\n    state.component.remove();\n  },\n};\n\nEditableLabel.Factory = {\n  create: function(opts) { return new EditableLabel(opts); },\n\n};\nmodule.exports = EditableLabel;\n",
    "var colors = require('./colors');\nvar utils = require('./utils');\nvar Logger = require('./Logger');\nvar LOG = new Logger('Graph');\n\nfunction Graph(opts) {\n  this.state = opts && opts.state;\n  this.adapter = opts && opts.adapter;\n  this.actionQueue = opts && opts.actionQueue;\n  this.labelSet = opts && opts.labelSet;\n\n  this.colorChoices = (opts && opts.colorChoices) || utils.startingAt(colors.RAINBOW, colors.INDIGO);\n  this.nodeSize = opts && opts.nodeSize;\n  this.edgeDistance = opts && opts.edgeDistance;\n  this.initialNodes = (opts && opts.initialNodes) || [];\n  this.initialEdges = (opts && opts.initialEdges) || [];\n}\n\nGraph.prototype = {\n  initialize: function(opts) {\n    this._validate();\n    LOG.debug('initializing graph', this);\n\n    this.adapter.initialize(\n      opts.element,\n      utils.optional({\n        width: opts.width,\n        height: opts.height,\n        nodes: this.initialNodes.map((function(n) {\n          return utils.optional({\n            id: n.id,\n            color: n.color || this.colorChoices[0],\n            label: '',\n            size: this.nodeSize,\n          }, { force: ['id', 'label'] });\n        }).bind(this)),\n        edges: this.initialEdges,\n        edgeDistance: this.edgeDistance,\n      })\n    );\n    this.actionQueue.defer((function() {\n      LOG.debug('initializing label set');\n      this.labelSet.initialize(\n        this.initialNodes.map((function(n) {\n          return {\n            node: this.adapter.getNode(n.id),\n            label: n.label,\n          };\n        }).bind(this))\n      );\n    }).bind(this));\n  },\n\n  addNode: function() {\n    var nodeId = this.state.persistNode({\n      color: this.colorChoices[0],\n    });\n    var node = utils.optional({\n      id: nodeId,\n      color: this.colorChoices[0],\n      label: '',\n      size: this.nodeSize,\n    }, { force: ['id', 'label'] });\n    this.adapter.addNode(node);\n  },\n\n  changeColor: function(node) {\n    var colorIndex = this._getNextColorIndex(node);\n    var newColor = this.colorChoices[colorIndex];\n    this.adapter.setNodeColor(node, newColor);\n    this.state.persistNode({ id: node.id, color: newColor });\n  },\n\n  addEdge: function(source, target) {\n    this.adapter.addEdge({\n      source: source,\n      target: target,\n      distance: this.edgeDistance,\n    });\n    this.state.persistEdge(source.id, target.id);\n  },\n\n  reset: function() {\n    this.adapter.performInBulk((function() {\n      this.state.retrievePersistedNodes().forEach((function(node) {\n        this.adapter.removeNode(node);\n      }).bind(this));\n    }).bind(this));\n\n    this.state.reset();\n    this.labelSet.closeAll();\n  },\n\n  _getNextColorIndex: function(node) {\n    var colorIndex = this.colorChoices.indexOf(node.color);\n    return (colorIndex + 1) % this.colorChoices.length;\n  },\n\n  _validate: function() {\n    if (!this.state) {\n      throw new Error('state is required');\n    }\n    if (!this.adapter) {\n      throw new Error('adapter is required');\n    }\n    if (!this.actionQueue) {\n      throw new Error('actionQueue is required');\n    }\n    if (!this.labelSet) {\n      throw new Error('labelSet is required');\n    }\n  },\n};\n\nmodule.exports = Graph;\n",
    "var Component = require('./Component');\nvar utils = require('./utils');\nvar Logger = require('./Logger');\nvar LOG = new Logger('GraphComponent');\n\n\nfunction GraphComponent(opts) {\n  Component.apply(this, arguments);\n  this.adapter = opts && opts.adapter;\n  this.editMode = opts && opts.editMode;\n  this.graph = opts && opts.graph;\n  this.width = opts && opts.width;\n  this.height = opts && opts.height;\n  this.nodeAreaFuzzFactor = opts.nodeAreaFuzzFactor;\n}\n\n\nGraphComponent.prototype = Object.assign(new Component(), {\n  doAttach: function(targetElement) {\n    this.graph.initialize({\n      element: targetElement,\n      width: this.width,\n      height: this.height,\n    });\n  },\n\n  handleClick: function(event) {\n    var clickTarget = this.adapter.getClickTarget(\n      event, this.nodeAreaFuzzFactor\n    );\n\n    this.editMode.perform({\n      ifActive: (function(currentlyEditedNode) {\n        if (clickTarget.isNode() && clickTarget.id !== currentlyEditedNode.id) {\n          this.graph.addEdge(currentlyEditedNode, clickTarget);\n       } else {\n          this.editMode.deactivate();\n        }\n      }).bind(this),\n\n      ifNotActive: (function() {\n        if (clickTarget.isNode()) {\n          this.graph.changeColor(clickTarget);\n        } else {\n          this.graph.addNode();\n        }\n      }).bind(this)\n    });\n  },\n\n  handleClickAndHold: function(event) {\n    var clickTarget = this.adapter.getClickTarget(\n      event, this.nodeAreaFuzzFactor\n    );\n    if (clickTarget.isNode()) {\n      this.editMode.activate(clickTarget);\n    }\n  },\n\n  reset: function() {\n    this.graph.reset();\n    this.editMode.deactivate();\n  },\n\n  _validateOptions: function() {\n    Component.prototype._validateOptions.call(this, arguments);\n    if (!this.adapter) {\n      throw new Error('adapter is required');\n    }\n    if (!this.editMode) {\n      throw new Error('edit mode is required');\n    }\n    if (!this.graph) {\n      throw new Error('graph is required');\n    }\n  },\n});\n\nmodule.exports = GraphComponent;\n",
    "var graphelements = require('./graphelements');;\nvar utils = require('./utils');\nvar BoundingBox = require('./BoundingBox');\nvar Logger = require('./Logger');\nvar LOG = new Logger('GreulerAdapter');\n\n\nfunction GreulerAdapter(greuler) {\n  this.greuler = greuler;\n  this.isInBulkOperation = false;\n}\n\n\nGreulerAdapter.prototype = {\n  initialize: function(targetNode, options) {\n    options = options || {};\n    this.instance = this.greuler(utils.optional({\n      target: '#' + targetNode.id,\n      width: options.width,\n      height: options.height,\n      data: utils.optional({\n        nodes: (options.nodes && options.nodes.map(this._translateNodeObj)),\n        links: options.edges,\n        linkDistance: options.edgeDistance && function() {\n          return options.edgeDistance;\n        },\n      }),\n    })).update();\n    this.graph = this.instance.graph;\n  },\n\n  addNode: function(node) {\n    var result = this.graph.addNode(this._translateNodeObj(node));\n    this._updateInstance();\n  },\n\n  removeNode: function(node) {\n    var result = this.graph.removeNode(this._translateNodeObj(node));\n    this._updateInstance();\n  },\n\n  addEdge: function(options) {\n    var result = this.graph.addEdge(utils.optional({\n      source: options.source.id,\n      target: options.target.id,\n      linkDistance: options.distance,\n    }, { force: ['source', 'target'] }));\n    this._updateInstance();\n  },\n\n  setNodeColor: function(target, color) {\n    if (target.domElement) {\n      target.domElement.setAttribute('fill', color);\n    } else if (target.id) {\n      var node = this.graph.getNode({ id: target.id });\n      this._getDomElement(node).setAttribute('fill', color);\n    } else {\n      LOG.error('Got unexpected target node', target);\n    }\n  },\n\n  getClickTarget: function(event, nodeAreaFuzzFactor) {\n    return this._getTargetNode(event, nodeAreaFuzzFactor) || graphelements.NONE;\n  },\n\n  getNode: function(nodeId) {\n    LOG.debug('retrieving node', nodeId);\n    return this.getNodes(function(n) { return n.id === nodeId; })[0];\n  },\n\n  getNodes: function(filter) {\n    filter = filter || function() { return true; };\n    return this.graph.getNodesByFn(filter).map((function(node) {\n      var domElement = this._getDomElement(node);\n      return new graphelements.Node({\n        id: node.id,\n        realNode: node,\n        domElement: domElement,\n        color: domElement.getAttribute('fill'),\n        getCurrentBoundingBox: this._getBoundingBox.bind(this, node),\n      });\n    }).bind(this));\n  },\n\n  performInBulk: function(actions) {\n    this.isInBulkOperation = true;\n    actions(this);\n    this.isInBulkOperation = false;\n    this._updateInstance();\n  },\n\n  _translateNodeObj: function(node) {\n    return utils.optional({\n      id: node.id,\n      fill: node.color,\n      label: node.label || '',\n      r: node.size,\n    }, { force: ['id', 'label'] });\n  },\n\n  _getDomElement: function(node) {\n    LOG.debug('retrieving dom element for node: ' + node.index, this.instance);\n    var childNodes = this.instance.nodeGroup[0][0].childNodes;\n    LOG.debug(childNodes);\n    return childNodes[node.index].getElementsByTagName('circle')[0];\n  },\n\n  _getTargetNode: function(event, nodeAreaFuzzFactor) {\n    nodeAreaFuzzFactor = nodeAreaFuzzFactor || 0;\n    var point = {\n      x: event.clientX,\n      y: event.clientY,\n    };\n    var matchingNodes = this.getNodes((function(node) {\n      return this._getBoundingBox(node)\n        .expandBy(nodeAreaFuzzFactor)\n        .contains(point);\n    }).bind(this));\n\n    if (matchingNodes && matchingNodes.length) {\n      matchingNodes.sort(function(a, b) {\n        var distanceToA = utils.distance(a.getCenter(), point);\n        var distanceToB = utils.distance(b.getCenter(), point);\n        return distanceToA - distanceToB;\n      });\n      return matchingNodes[0];\n    } else {\n      return undefined;\n    }\n  },\n\n  _updateInstance: function() {\n    if (!this.isInBulkOperation) {\n      this.instance = this.instance.update();\n    }\n  },\n\n  _getBoundingBox: function(node) {\n    var graphElementBounds = this.instance.root[0][0].getBoundingClientRect();\n    return new BoundingBox({\n      left: node.bounds.x,\n      right: node.bounds.X,\n      top: node.bounds.y,\n      bottom: node.bounds.Y,\n    })\n    .translate({\n      x: graphElementBounds.left,\n      y: graphElementBounds.top\n    });\n  },\n};\n\nmodule.exports = GreulerAdapter;\n",
    "var Graph = require('./Graph');\n\nfunction ImmutableGraph() {\n  Graph.apply(this, arguments);\n}\n\nImmutableGraph.prototype = Object.assign(new Graph(), {\n\n  addNode: function() {},\n  changeColor: function() {},\n  addEdge: function() {},\n  reset: function() {},\n\n});\n\nmodule.exports = ImmutableGraph;\n",
    "var LEVEL_ORDER = [\n  'DEBUG',\n  'INFO',\n  'WARN',\n  'ERROR',\n];\n\nfunction Logger(name) {\n  this.name = name || 'Logger';\n}\n\nLogger.level = 'WARN';\nLogger.levels = {};\n\nLogger.prototype = {\n  debug: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'DEBUG', this.name].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  info: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'INFO', this.name].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  warn: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'WARN', this.name].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  error: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'ERROR', this.name].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n\n  _log: function() {\n    var level = arguments[1];\n    var logLevel = Logger.levels[this.name] || Logger.level;\n    if (LEVEL_ORDER.indexOf(level) >= LEVEL_ORDER.indexOf(logLevel)) {\n      global.console.log.apply(global.console.log, arguments);\n    }\n  },\n};\n\n\nmodule.exports = Logger;\n",
    "var Logger = require('./Logger');\nvar LOG = new Logger('ModeSwitch');\n\nfunction ModeSwitch(opts) {\n  this.actionQueue = opts && opts.actionQueue;\n  this.timeout = (opts && opts.timeout) || 0;\n  this.modeStates = (opts && opts.initialStates) || {};\n  this.name = (opts && opts.name) || 'ModeSwitch';\n  this.currentMode = null;\n  this.resetModeFuture = null;\n  LOG.debug('Initialized ' + this.name, this);\n}\n\nModeSwitch.prototype = {\n  enter: function(mode, fn) {\n    this._validate();\n    if (this._isPermitted(mode)) {\n      LOG.debug(this.name + ': Entering \\'' + mode + '\\'', this);\n      var state = (fn || function() {})();\n      this.modeStates[mode] = state;\n      this.currentMode = mode;\n      this._cancelModeReset();\n    } else {\n      LOG.debug(this.name + ': Not entering \\'' + mode + '\\';'\n                + ' active mode is ' + this.currentMode, this);\n    }\n    return this;\n  },\n\n  exit: function(mode, fn) {\n    this._validate();\n    if(this._isActive(mode)) {\n      LOG.debug(this.name + ': Exiting ' + mode, this);\n      (fn || function() {})(this.modeStates[mode]);\n      this._scheduleModeReset();\n    } else {\n      LOG.debug(this.name + ': Not exiting \\'' + mode + '\\';'\n                + ' active mode is ' + this.currentMode, this);\n    }\n    return this;\n  },\n\n  ifActive: function(callbackObj) {\n    var activeMode = this.currentMode || 'default';\n    var callback = callbackObj[activeMode];\n    if (callback) {\n      LOG.debug(this.name + ': Found callback for active mode', activeMode, callbackObj);\n      var modeState = this.modeStates[this.currentMode || 'default'];\n      callback(modeState);\n    } else {\n      LOG.debug(this.name + ': No callback for active mode', activeMode, callbackObj);\n    }\n    return this;\n  },\n\n  _isPermitted: function(mode) {\n    return !this.currentMode || this._isActive(mode);\n  },\n\n  _isActive: function(mode) {\n    return this.currentMode === mode;\n  },\n\n  _cancelModeReset: function() {\n    this.resetModeFuture && this.resetModeFuture.cancel();\n  },\n\n  _scheduleModeReset: function() {\n    var resetFunction = (function() {\n      delete this.modeStates[this.currentMode];\n      this.currentMode = null;\n    }).bind(this);\n\n    this._cancelModeReset();\n    if (this.timeout) {\n      this.resetModeFuture = this.actionQueue.defer(\n        this.timeout, resetFunction\n      );\n    } else {\n      resetFunction();\n    }\n  },\n\n  _validate: function() {\n    if(this.timeout && !this.actionQueue) {\n      throw new Error('action queue is required if a timeout is specified');\n    }\n  },\n};\n\nmodule.exports = ModeSwitch;\n",
    "var Position = require('./Position');\nvar EditableLabel = require('./EditableLabel');\nvar Logger = require('./Logger');\nvar LOG = new Logger('NodeLabelSet');\n\nfunction NodeLabelSet(opts) {\n  this.componentManager = opts && opts.componentManager;\n  this.state = opts && opts.state;\n  this.editableLabelFactory = (opts && opts.editableLabelFactory) || EditableLabel.Factory;\n  this.labels = {};\n}\n\nNodeLabelSet.prototype = {\n\n  initialize: function(initialData) {\n    LOG.debug('initializing', initialData);\n    initialData\n      .filter(function(o) { return !!o.label; })\n      .forEach((function(o) {\n        var label = this._createLabel(o.node, o.label);\n        this.labels[o.node.id] = label;\n        label.display();\n      }).bind(this));\n  },\n\n  edit: function(node) {\n    LOG.debug('editing label for node ' + node.id);\n    this._getOrCreateLabel(node).edit();\n  },\n\n  display: function(node) {\n    LOG.debug('displaying label for node ' + node.id);\n    this._getOrCreateLabel(node).display();\n  },\n\n  closeAll: function() {\n    Object.values(this.labels).forEach(function(label) {\n      label.remove();\n    });\n    this.labels = {};\n  },\n\n  _getOrCreateLabel: function(node) {\n    var label;\n    if (this.labels[node.id]) {\n      label = this.labels[node.id];\n      LOG.info('reusing existing label for node ' + node.id, label);\n    } else {\n      label = this._createLabel(node);\n      this.labels[node.id] = label;\n      LOG.info('created new label for node ' + node.id, label);\n    }\n    return label;\n  },\n\n  _createLabel: function(node, label) {\n    LOG.debug('Creating label', node);\n    return this.editableLabelFactory.create({\n      text: label,\n      componentManager: this.componentManager,\n      pinTo: function() {\n        return new Position({\n          bottomRight: node.getCurrentBoundingBox().getTopLeft(),\n        });\n      },\n      onChange: (function(text) {\n        LOG.debug('saving label', node, text);\n        this.state.persistNode({ id: node.id, label: text });\n      }).bind(this),\n    });\n  },\n\n  _validate: function() {\n    if (!this.componentManager) {\n      throw new Error('componentManager is required');\n    }\n    if (!this.state) {\n      throw new Error('state is required');\n    }\n  },\n};\n\nmodule.exports = NodeLabelSet;\n",
    "var utils = require('./utils');\n\nfunction Position(opts) {\n  /* opts -\n   * {\n    topLeft: { x: 0, y: 0 },\n    topRight: undefined,\n    bottomLeft: undefined,\n    bottomRight: undefined,\n    }\n   */\n  if (!utils.isOneValuedObject(opts)) {\n    throw new Error('invalid position object ' + opts);\n  }\n\n  Object.assign(this, opts);\n}\n\n\nPosition.prototype = {\n  getStyle: function(opts) {\n    opts = Object.assign({\n      width: 0,\n      height: 0,\n    }, opts);\n\n    if (this.topLeft) {\n        return 'position: absolute;' +\n        ' left: ' + this.topLeft.x + ';' +\n        ' top: ' + this.topLeft.y + ';';\n    } else if (this.topRight) {\n      return 'position: absolute;' +\n        ' left: ' + (this.topRight.x - opts.width) + ';' +\n        ' top: ' + this.topRight.y + ';';\n    } else if (this.bottomLeft) {\n      return 'position: absolute;' +\n        ' left: ' + this.bottomLeft.x + ';' +\n        ' top: ' + (this.bottomLeft.y - opts.height) + ';';\n    } else if (this.bottomRight) {\n      return 'position: absolute;' +\n        ' left: ' + (this.bottomRight.x  - opts.width)+ ';' +\n        ' top: ' + (this.bottomRight.y - opts.height) + ';';\n    } else {\n      throw new Error('invalid position object: ' + this);\n    }\n  },\n};\n\nmodule.exports = Position;\n",
    "var Component = require('./Component');\n\nfunction ResetButton(options) {\n  Component.apply(this, arguments);\n  if (options) {\n    this.resettables = options.resettables;\n  } else {\n    this.resettables = [];\n  }\n\n}\n\nResetButton.prototype = Object.assign(new Component(), {\n  handleClick: function(event) {\n    this.resettables.forEach(function(resettable) {\n      resettable.reset();\n    });\n  },\n});\n\nmodule.exports = ResetButton;\n",
    "var Component = require('./Component');\n\nfunction TextBox(options) {\n  Component.apply(this, arguments);\n  this.initialText = (options && options.text) || '';\n  this.onSave = (options && options.onSave) || function() {};\n}\n\nTextBox.prototype = Object.assign(new Component(), {\n  getGeneratedMarkup: function() {\n    return '<input type=\"text\"' +\n    ' value=\"' + this.initialText + '\"' +\n    '></input>';\n  },\n\n  getText: function() {\n    return this.element.getElementsByTagName('input')[0].value;\n  },\n\n  handleEnter: function(event) {\n    this.onSave();\n  },\n});\n\nmodule.exports = TextBox;\n",
    "var utils = require('./utils');\n\nNUM_NODES_PARAM = 'n'\nCOLOR_PARAM_PREFIX = 'c_';\nEDGE_PARAM_PREFIX = 'e_';\nLABEL_PARAM_PREFIX = 'l_';\n\nfunction UrlState(options) {\n  this.baseUrl = (options && options.baseUrl);\n  this.setUrl = (options && options.setUrl);\n  this.urlSearchParams = (options && options.urlSearchParams);\n}\n\nUrlState.prototype = {\n  /**\n   * Perist a node and return its id\n   */\n  persistNode: function(options) {\n    options = options || {};\n    var nodeId;\n    if (options.hasOwnProperty('id') && options.id !== null && options.id !== undefined) {\n      nodeId = options.id;\n    } else {\n      nodeId = this._getNumNodes();\n      this.urlSearchParams.set(NUM_NODES_PARAM, nodeId + 1);\n    }\n\n    if (options.color) {\n      this._setNodeColor(nodeId, options.color);\n    }\n\n    if (options.label) {\n      this._setNodeLabel(nodeId, options.label);\n    }\n\n    this._persistState();\n    return nodeId;\n  },\n\n  retrieveNode: function(nodeId) {\n    var nodeBit = this._idToBit(nodeId);\n    var nodeColor = this._getColorKeys().find((function(param) {\n      return this._isColor({ bit: nodeBit, colorKey: param });\n    }).bind(this));\n    var label = this.urlSearchParams.get(LABEL_PARAM_PREFIX + nodeId);\n    return utils.optional({\n      id: nodeId,\n      color: (nodeColor && nodeColor.replace(COLOR_PARAM_PREFIX, '#')),\n      label: label && decodeURIComponent(label),\n    }, { force: 'id' });\n  },\n\n  persistEdge: function(sourceId, targetId) {\n    var param = EDGE_PARAM_PREFIX + sourceId;\n    var bitmask;\n    if (this.urlSearchParams.has(param)) {\n      bitmask = this._getBitmaskParam(param) | this._idToBit(targetId);\n    } else {\n      bitmask = this._idToBit(targetId);\n    }\n    this._setBitmaskParam(param, bitmask);\n    this._persistState();\n  },\n\n  retrievePersistedNodes: function() {\n    var nodes = [];\n    if (this.urlSearchParams.has(NUM_NODES_PARAM)) {\n      for (var i = 0 ; i < this.urlSearchParams.get(NUM_NODES_PARAM); i++) {\n        nodes.push(this.retrieveNode(i));\n      }\n    }\n    return nodes;\n  },\n\n  retrievePersistedEdges: function() {\n    return this._getEdgeKeys().map((function(key) {\n      var sourceId = parseInt(key.replace(EDGE_PARAM_PREFIX, ''));\n      var edges = [];\n      var bitmask = this._getBitmaskParam(key);\n      var maxId = bitmask.toString(2).length;\n      for (var targetId = 0; targetId < maxId; targetId++) {\n        var bit = this._idToBit(targetId);\n        if ((bitmask & bit) === bit) {\n          edges.push({ source: sourceId, target: targetId });\n        }\n      }\n      return edges;\n    }).bind(this))\n    .reduce(function(a, b) { return a.concat(b); }, []);\n  },\n\n  _setNodeLabel: function(nodeId, label) {\n    this.urlSearchParams.set(\n      LABEL_PARAM_PREFIX + nodeId,\n      encodeURIComponent(label)\n    );\n  },\n\n  getUrl: function() {\n    return this.baseUrl + '?' + this.urlSearchParams.toString();\n  },\n\n  reset: function() {\n    this._getKeys().forEach((function(key) {\n      this.urlSearchParams.delete(key);\n    }).bind(this));\n    this._persistState();\n  },\n\n  _isColor: function(options) {\n    options = this._normalizeColorOptions(options);\n\n    if (this.urlSearchParams.has(options.colorKey)) {\n      return (this._getBitmaskParam(options.colorKey) & options.bit) === options.bit;\n    } else {\n      return false;\n    }\n  },\n\n  _setColor: function(options) {\n    options = this._normalizeColorOptions(options);\n    var bitmask;\n\n    if (this.urlSearchParams.has(options.colorKey)) {\n      bitmask = this._getBitmaskParam(options.colorKey) | options.bit;\n    } else {\n      bitmask = options.bit;\n    }\n    this._setBitmaskParam(options.colorKey, bitmask);\n  },\n\n  _removeColor: function(options) {\n    options = this._normalizeColorOptions(options);\n    if (!this.urlSearchParams.has(options.colorKey)) {\n      throw Error('Attempted to remove color ' + options.colorKey);\n    }\n    var bitmask = this._getBitmaskParam(options.colorKey) & (~options.bit);\n    if (bitmask === 0) {\n      this.urlSearchParams.delete(options.colorKey);\n    } else {\n      this._setBitmaskParam(options.colorKey, bitmask);\n    }\n  },\n\n  _getBitmaskParam: function(key) {\n    return parseInt(this.urlSearchParams.get(key), 16);\n  },\n\n  _setBitmaskParam: function(key, value) {\n    this.urlSearchParams.set(key, value.toString(16));\n  },\n\n  _idToBit: function(id) {\n    if (id <= 30) {\n      return 1 << id;\n    } else {\n      return Math.pow(2, id);\n    }\n  },\n\n  _normalizeColorOptions: function(options) {\n    if (!options.hasOwnProperty('bit') && !options.hasOwnProperty('nodeId')) {\n      throw Error('bit or nodeId is required');\n    }\n    if (!options.hasOwnProperty('color') && !options.hasOwnProperty('colorKey')) {\n      throw Error('color or colorKey is required');\n    }\n    var bit = options.hasOwnProperty('bit')\n      ? options.bit\n      : this._idToBit(options.nodeId);\n    var colorKey = options.hasOwnProperty('colorKey')\n      ? options.colorKey\n      : options.color.replace('#', COLOR_PARAM_PREFIX);\n    return { bit: bit, colorKey: colorKey };\n  },\n\n  _getColorKeys: function() {\n    return this._getKeys(function(k) {\n      return k.startsWith(COLOR_PARAM_PREFIX);\n    });\n  },\n\n  _getEdgeKeys: function() {\n    return this._getKeys(function(k) {\n      return k.startsWith(EDGE_PARAM_PREFIX);\n    });\n  },\n\n  _getKeys: function(predicate) {\n    predicate = predicate || function() { return true; };\n    var keys = [];\n    var iterator = this.urlSearchParams.keys();\n    var next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        keys.push(next.value);\n      }\n      next = iterator.next();\n    }\n    return keys;\n  },\n\n  _getNumNodes: function() {\n    if (this.urlSearchParams.has(NUM_NODES_PARAM)) {\n      return parseInt(this.urlSearchParams.get(NUM_NODES_PARAM));\n    } else {\n      return 0;\n    }\n  },\n\n  _setNodeColor: function(nodeId, color) {\n    var bit = this._idToBit(nodeId);\n\n    this._getColorKeys().forEach((function(key) {\n      if (this._isColor({ bit: bit, colorKey: key })) {\n        this._removeColor({ bit: bit, colorKey: key });\n      }\n    }).bind(this));\n\n    this._setColor({ bit: bit, color: color });\n  },\n\n\n  _persistState: function() {\n    this.setUrl(this.getUrl());\n  },\n};\n\nmodule.exports = UrlState;\n",
    "var RED = '#db190f';\nvar ORANGE = '#f76402';\nvar YELLOW = '#fbff14';\nvar GREEN = '#28b92b';\nvar BLUE = '#2826b5';\nvar INDIGO = '#2980B9';\nvar VIOLET = '#8c28b7';\nvar NEON = '#00FF00';\n\nmodule.exports = {\n  RED: RED,\n  ORANGE: ORANGE,\n  YELLOW: YELLOW,\n  GREEN: GREEN,\n  BLUE: BLUE,\n  INDIGO: INDIGO,\n  VIOLET: VIOLET,\n  NEON: NEON,\n  RAINBOW: [\n    RED,\n    ORANGE,\n    YELLOW,\n    GREEN,\n    BLUE,\n    INDIGO,\n    VIOLET,\n  ],\n};\n",
    "function GraphElement(options) {\n  if (options) {\n    this.id = options.id;\n    this.domElement = options.domElement;\n  }\n}\n\nGraphElement.prototype = {\n  isNode: function() {\n    return false;\n  },\n  isEdge: function() {\n    return false;\n  },\n};\n\nfunction Node(options) {\n  GraphElement.apply(this, arguments);\n  if (options) {\n    this.realNode = options.realNode;\n    this.color = options.color;\n    this.getCurrentBoundingBox = options.getCurrentBoundingBox;\n  }\n}\n\nNode.prototype = Object.assign(new GraphElement(), {\n  isNode: function() { return true; },\n\n  getCenter: function() {\n    return this.getCurrentBoundingBox().getCenter();\n  },\n\n  getTopLeft: function() {\n    return this.getCurrentBoundingBox().getTopLeft();\n  },\n\n  getTopRight: function() {\n    return this.getCurrentBoundingBox().getTopRight();\n  },\n\n  getBottomLeft: function() {\n    return this.getCurrentBoundingBox().getBottomLeft();\n  },\n\n  getBottomRight: function() {\n    return this.getCurrentBoundingBox().getBottomRight();\n  },\n});\n\n\nfunction Edge() {\n  GraphElement.apply(this, arguments);\n}\n\nEdge.prototype = Object.assign(new GraphElement(), {\n  isEdge: function() { return true; },\n});\n\nfunction None() {\n  GraphElement.apply(this, arguments);\n}\n\nNone.prototype = Object.assign(new GraphElement(), {\n\n});\n\nmodule.exports = {\n  Node: Node,\n  Edge: Edge,\n  NONE: new None(),\n};\n",
    "var Animator = require('./Animator');\nvar ColorChangingGraph = require('./ColorChangingGraph');\nvar ComponentManager = require('./ComponentManager');\nvar DisallowedEditMode = require('./DisallowedEditMode');\nvar EditMode = require('./EditMode');\nvar Graph = require('./Graph');\nvar GraphComponent = require('./GraphComponent');\nvar GreulerAdapter = require('./GreulerAdapter');\nvar ImmutableGraph = require('./ImmutableGraph');\nvar NodeLabelSet = require('./NodeLabelSet');\nvar utils = require('./utils');\n\nvar Logger = require('./Logger');\nvar LOG = new Logger('graphfactory');\n\nmodule.exports = {\n\n  newImmutableGraph: function(opts) {\n    LOG.debug('instantiating immmutable graph', opts);\n    var actionQueue = utils.requireNonNull(opts.actionQueue);\n    var state = utils.requireNonNull(opts.state);\n    var adapter = utils.requireNonNull(opts.adapter);\n\n    var labelSet = opts.labelSet || new NodeLabelSet({\n      componentManager: opts.componentManager || this._newComponentManager(opts),\n      state: state,\n    });\n\n\n    return new ImmutableGraph({\n      state: state,\n      adapter: adapter,\n      actionQueue: actionQueue,\n      labelSet: labelSet,\n      initialNodes: opts.initialNodes,\n      initialEdges: opts.initialEdges,\n      nodeSize: opts.nodeSize,\n      edgeDistance: opts.edgeDistance,\n      colorChoices: opts.colorChoices,\n    });\n  },\n\n  newColorChangingGraph: function(opts) {\n    LOG.debug('instantiating color changing graph', opts);\n    var actionQueue = utils.requireNonNull(opts.actionQueue);\n    var state = utils.requireNonNull(opts.state);\n    var adapter = utils.requireNonNull(opts.adapter);\n\n    var labelSet = opts.labelSet || new NodeLabelSet({\n      componentManager: opts.componentManager || this._newComponentManager(opts),\n      state: state,\n    });\n\n    return new ColorChangingGraph({\n      state: state,\n      adapter: adapter,\n      actionQueue: actionQueue,\n      labelSet: labelSet,\n      initialNodes: opts.initialNodes,\n      initialEdges: opts.initialEdges,\n      nodeSize: opts.nodeSize,\n      edgeDistance: opts.edgeDistance,\n      colorChoices: opts.colorChoices,\n    });\n  },\n\n  newMutableGraph: function(opts) {\n    LOG.debug('instantiating mutable graph', opts);\n    var actionQueue = utils.requireNonNull(opts.actionQueue);\n    var state = utils.requireNonNull(opts.state);\n    var adapter = utils.requireNonNull(opts.adapter);\n\n    var labelSet = opts.labelSet || new NodeLabelSet({\n      componentManager: opts.componentManager || this._newComponentManager(opts),\n      state: state,\n    });\n\n    return new Graph({\n      state: state,\n      adapter: adapter,\n      actionQueue: actionQueue,\n      labelSet: labelSet,\n      initialNodes: opts.initialNodes,\n      initialEdges: opts.initialEdges,\n      nodeSize: opts.nodeSize,\n      edgeDistance: opts.edgeDistance,\n      colorChoices: opts.colorChoices,\n    });\n  },\n\n  newGraph: function(opts) {\n    if (opts.immutable) {\n      return this.newImmutableGraph(opts);\n    } else if (opts.onlyChangeColors) {\n      return this.newColorChangingGraph(opts);\n    } else {\n      return this.newMutableGraph(opts);\n    }\n  },\n\n  newGraphComponent: function(opts) {\n    var actionQueue = utils.requireNonNull(opts.actionQueue);\n    var adapter = utils.requireNonNull(opts.adapter);\n    var state = utils.requireNonNull(opts.state);\n    var componentManager = opts.componentManager = this._newComponentManager(opts);\n    var labelSet = new NodeLabelSet({\n      componentManager: componentManager,\n      state: state,\n    });\n\n    var editMode;\n\n    if (opts.immutable || opts.onlyChangeColors) {\n      editMode = new DisallowedEditMode();\n    } else {\n      editMode = new EditMode({\n        adapter: adapter,\n        animator: new Animator({ actionQueue: actionQueue }),\n        labelSet: labelSet,\n        alternateInterval: opts.alternateInterval,\n      });\n    }\n\n\n    return new GraphComponent(Object.assign({\n      graph: this.newGraph(opts),\n      adapter: adapter,\n      editMode: editMode,\n      width: opts.width,\n      height: opts.height,\n      nodeAreaFuzzFactor: opts.nodeAreaFuzzFactor,\n    }, this._getComponentServices(opts)));\n  },\n\n  _newComponentManager: function(opts) {\n    return new ComponentManager({\n      actionQueue: utils.requireNonNull(opts.actionQueue),\n      componentServices: this._getComponentServices(opts),\n      document: utils.requireNonNull(opts.document),\n    });\n  },\n\n  _getComponentServices: function(opts) {\n    var actionQueue = utils.requireNonNull(opts.actionQueue);\n    return { actionQueue: actionQueue };\n  },\n};\n",
    "/**\n * Compute the cartesian distance between two vectors\n */\nfunction distance(point1, point2) {\n  var x = point1.x - point2.x;\n  var y = point1.y - point2.y;\n  return Math.sqrt(x*x + y*y);\n}\n\n/**\n * Construct an object that has all the key-values for which values\n * are present in the input.\n */\nfunction optional(keyValuePairs, options) {\n  var obj = {};\n  Object.keys(keyValuePairs).forEach(function(key) {\n    if (keyValuePairs[key]) {\n      obj[key] = keyValuePairs[key];\n    }\n  });\n  if (options && options.force) {\n    if (options.force.constructor === Array) {\n      options.force.forEach(function(key) {\n        obj[key] = keyValuePairs[key];\n      });\n    } else {\n      obj[options.force] = keyValuePairs[options.force];\n    }\n  }\n  return obj;\n}\n\n\nfunction normalizeEvent(event) {\n  if (event && event.touches && event.touches.length) {\n    return Object.assign(\n      event,\n      {\n        clientX: event.touches[0].clientX,\n        clientY: event.touches[0].clientY,\n        screenX: event.touches[0].screenX,\n        screenY: event.touches[0].screenY,\n      }\n    );\n  } else {\n    return event;\n  }\n}\n\nfunction isOneValuedObject(obj) {\n  if (obj && (typeof obj === 'object') && !Array.isArray(obj)) {\n    var presentKeys = Object.keys(obj)\n      .filter(function(k) { return !!obj[k]; });\n    return presentKeys.length === 1\n  } else {\n    return false;\n  }\n}\n\nfunction startingAt(array, startingItem) {\n  var startingIndex = array.indexOf(startingItem)\n  if (startingIndex >= 0) {\n    var returnValue = [];\n    for (var i = startingIndex; i < array.length; i++) {\n      returnValue.push(array[i]);\n    }\n    for (var i = 0; i < startingIndex; i++) {\n      returnValue.push(array[i]);\n    }\n    return returnValue;\n  } else {\n    return array;\n  }\n}\n\nfunction requireNonNull(obj) {\n  if (!obj) {\n    throw new Error('missing required object');\n  }\n  return obj;\n}\n\nmodule.exports = {\n  distance: distance,\n  optional: optional,\n  normalizeEvent: normalizeEvent,\n  isOneValuedObject: isOneValuedObject,\n  startingAt: startingAt,\n  requireNonNull: requireNonNull,\n};\n"
  ]
}