{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "main.js",
    "src/ActionQueue.js",
    "src/Animator.js",
    "src/Component.js",
    "src/ComponentManager.js",
    "src/Logger.js",
    "src/ModeSwitch.js",
    "src/colors.js",
    "src/components/BlockText.js",
    "src/components/GraphComponent.js",
    "src/components/ResetButton.js",
    "src/components/TextBox.js",
    "src/geometry/BoundingBox.js",
    "src/geometry/Position.js",
    "src/graphs/ColorChanger.js",
    "src/graphs/EdgeCreator.js",
    "src/graphs/Graph.js",
    "src/graphs/GreulerAdapter.js",
    "src/graphs/NoOpColorChanger.js",
    "src/graphs/NoOpEdgeCreator.js",
    "src/graphs/NoOpNodeCreator.js",
    "src/graphs/NodeCreator.js",
    "src/graphs/graphelements.js",
    "src/graphs/graphfactory.js",
    "src/labels/EditableLabel.js",
    "src/labels/EmptyLabelSet.js",
    "src/labels/NodeLabelSet.js",
    "src/modes/DisallowedEditMode.js",
    "src/modes/EditMode.js",
    "src/modes/NonAnimatingEditMode.js",
    "src/state/UrlState.js",
    "src/utils.js",
    "src/utils/Literal.js"
  ],
  "names": [],
  "mappings": "AAAA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7IA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "var GreulerAdapter = require('./src/graphs/GreulerAdapter');\nvar UrlState = require('./src/state/UrlState');\nvar ActionQueue = require('./src/ActionQueue');\nvar ResetButton = require('./src/components/ResetButton');\nvar graphfactory = require('./src/graphs/graphfactory');\n\nrequire('./src/Logger').level = global.logLevel;\n\nvar actionQueue = new ActionQueue();\nvar urlSearchParams = new URLSearchParams(window.location.search);\nvar state = new UrlState({\n  baseUrl: window.location.protocol + \"//\" + window.location.host + window.location.pathname,\n  setUrl: window.history.replaceState.bind(window.history, {}, ''),\n  urlSearchParams: urlSearchParams,\n});\n\n\nvar immutable = urlSearchParams.get('immutable') === 'true';\nvar allowAddNodes = urlSearchParams.get('allowAddNodes') !== 'false';\nvar allowAddEdges = urlSearchParams.get('allowAddEdges') !== 'false';\nvar allowEdit = urlSearchParams.get('allowEdit') !== 'false';\nvar allowChangeColors = urlSearchParams.get('allowChangeColors') !== 'false';\nvar allowLabels = urlSearchParams.get('allowLabels') !== 'false';\n\n\nglobal.graphComponent = graphfactory.newGraphComponent({\n  document: global.document,\n  screen: global.screen,\n  window: window,\n  size: 'fullscreen',\n  adapter: new GreulerAdapter({ greuler: global.greuler }),\n  actionQueue: actionQueue,\n  state: state,\n  nodeAreaFuzzFactor: 0.1,\n  alternateInterval: 250,\n  immutable: immutable,\n  allowAddNodes: allowAddNodes,\n  allowAddEdges: allowAddEdges,\n  allowChangeColors: allowChangeColors,\n  allowEdit: allowEdit,\n  allowLabels: allowLabels,\n  colorChoices: urlSearchParams.has('colorChoices') &&\n    urlSearchParams.getAll('colorChoices').map(function(c) { return '#' + c; }),\n  initialNodes: state.retrievePersistedNodes(),\n  initialEdges: state.retrievePersistedEdges(),\n});\n\nglobal.graph = global.graphComponent.graph;\n\nglobal.graphComponent.attachTo(document.getElementById('main-graph'));\n",
    "var Literal = require('./utils/Literal');\n\nfunction ActionQueue(options) {\n  this.setTimeout = (options && options.setTimeout) || global.setTimeout.bind(global);\n  this.clearTimeout = (options && options.clearTimeout) || global.clearTimeout.bind(global);\n  this.actionInterval = (options && options.actionInterval) || 10;\n  this.periodicActions = [];\n  this.hasStartedPeriodicActions = false;\n}\n\nActionQueue.prototype = {\n  className: 'ActionQueue',\n\n  defer: function(timeout, fn) {\n    if (arguments.length == 1) {\n      fn = timeout;\n      timeout = 1;\n    }\n    var timeoutId = this.setTimeout(fn, timeout);\n    return {\n      cancel: (function() {\n        this.clearTimeout(timeoutId);\n      }).bind(this),\n    };\n  },\n\n  periodically: function(fn) {\n    var periodicActions = this.periodicActions;\n    periodicActions.push(fn);\n\n    if(!this.hasStartedPeriodicActions) {\n      this._startPeriodicActions();\n    }\n\n    return {\n      cancel: function() {\n        periodicActions.splice(\n          periodicActions.indexOf(fn),\n          1\n        );\n      },\n    };\n  },\n\n  _startPeriodicActions: function() {\n      var queueFn = (function() {\n        this.periodicActions.forEach(function(fn) { fn(); });\n        this.setTimeout(queueFn, this.actionInterval);\n      }).bind(this);\n      queueFn();\n      this.hasStartedPeriodicActions = true;\n  },\n\n  getConstructorArgs: function() {\n    return {\n      setTimeout: new Literal('global.setTimeout.bind(global)'),\n      clearTimeout: new Literal('global.clearTimeout.bind(global)'),\n      actionInterval: this.actionInterval,\n    };\n  },\n};\n\nmodule.exports = ActionQueue;\n",
    "function Animator(options) {\n  this.actionQueue = (options && options.actionQueue);\n}\n\nAnimator.prototype = {\n  className: 'Animator',\n\n  alternate: function() {\n    this._checkDependencies();\n    return new AlternatingAnimation(this.actionQueue, Array.prototype.slice.call(arguments));\n  },\n\n  getConstructorArgs: function() {\n    return { actionQueue: this.actionQueue };\n  },\n\n  _checkDependencies: function() {\n    if (!this.actionQueue) {\n      throw Error('ActionQueue is required');\n    }\n  },\n};\n\nfunction AlternatingAnimation(actionQueue, functions) {\n  this.actionQueue = actionQueue;\n  this.functions = functions;\n  this.currentIndex = 0;\n  this.interval = 100;\n  this.predicate = function() { return true; };\n}\n\nAlternatingAnimation.prototype = {\n  every: function(interval) {\n    this.interval = interval;\n    return this;\n  },\n\n  asLongAs: function(predicate) {\n    this.predicate = predicate;\n    return this;\n  },\n\n  play: function() {\n    var execute = (function() {\n      if (this.predicate()) {\n        this.functions[this.currentIndex]();\n        this.currentIndex = (this.currentIndex + 1) % this.functions.length;\n        this.actionQueue.defer(this.interval, execute);\n      }\n    }).bind(this);\n    execute();\n    return this;\n  },\n\n  stop: function() {\n    return this.asLongAs(function() { return false; });\n  },\n};\n\nmodule.exports = Animator;\n",
    "var utils = require('./utils');\nvar ModeSwitch = require('./ModeSwitch');\nvar Logger = require('./Logger');\n\nvar LOG = new Logger('Component');\n\n/**\n * Component constructor\n *\n * options - service objects\n * options - options for the component.\n *         - holdTime - amount of time to wait before triggering a \"hold\" event\n */\nfunction Component(options) {\n  if (options) {\n    this.actionQueue = options.actionQueue;\n    this.holdTime = options.holdTime || 250;\n    this.mouseTouchSwitch = new ModeSwitch({\n      actionQueue: this.actionQueue,\n      timeout: 500,\n      name: 'mouseTouchSwitch',\n    });\n    this.constructorArgs = options;\n  }\n\n  this.mouseDownCount = 0;\n  this.mouseUpCount = 0;\n  this.isInClickAndHold = false;\n  this.closeListeners = [];\n}\n\nComponent.prototype = {\n  handleClick: function() {},\n  handleClickAndHold: function() {},\n  handleEnter: function() {},\n  className: '',\n\n  getConstructorArgs: function() { return this.constructorArgs; },\n\n  attachTo: function(targetElement) {\n    this._validateOptions();\n    this.element = targetElement;\n\n    targetElement.addEventListener('mouseup', (function(event) {\n      LOG.debug('mouseup', utils.normalizeEvent(event));\n      this.mouseTouchSwitch.exit('mouse', (function(modeState) {\n        this._handleMouseUp(modeState.lastDownEvent);\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('touchend', (function(event) {\n      LOG.debug('touchend', utils.normalizeEvent(event));\n      this.mouseTouchSwitch.exit('touch', (function(modeState) {\n        this._handleMouseUp(modeState.lastDownEvent);\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('mousedown', (function(event) {\n      event = utils.normalizeEvent(event);\n      LOG.debug('mousedown', event);\n      this.mouseTouchSwitch.enter('mouse', (function() {\n        this._handleMouseDown(event);\n        return { lastDownEvent: event };\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('touchstart', (function(event) {\n      event = utils.normalizeEvent(event);\n      LOG.debug('touchstart', event);\n      this.mouseTouchSwitch.enter('touch', (function() {\n        this._handleMouseDown(event);\n        return { lastDownEvent: event };\n      }).bind(this));\n    }).bind(this));\n\n    targetElement.addEventListener('keyup', (function(event) {\n      event = utils.normalizeEvent(event);\n      LOG.debug('keyup', event);\n      if (event.keyCode === 13) {\n        this.handleEnter(event);\n      }\n    }).bind(this));\n\n    if (this.getGeneratedMarkup()) {\n      targetElement.innerHTML = this.getGeneratedMarkup();\n    }\n\n    this.doAttach(targetElement);\n  },\n\n  /**\n   * subclasses can override to indicate initial markup\n   * to be set on the target element\n   */\n  getGeneratedMarkup: function() {\n    return null;\n  },\n\n  /**\n   * Sub-components should override to initialize on attachment\n   */\n  doAttach: function(element) {\n\n  },\n\n  onRemove: function(listener) {\n    this.closeListeners.push(listener);\n    return this;\n  },\n\n  remove: function() {\n    this.closeListeners.forEach((function(f) {\n      f(this);\n    }).bind(this));\n    this.element.remove();\n    LOG.debug('closed component', this);\n  },\n\n  _validateOptions: function() {\n    if (!this.actionQueue) {\n      throw Error('actionQueue is required');\n    }\n    if (!this.className) {\n      throw new Error('Must override className');\n    }\n  },\n\n  _handleMouseUp: function(event) {\n    this.mouseUpCount++;\n    if (this.isInClickAndHold) {\n      this.isInClickAndHold = false;\n    } else {\n      this.handleClick(event);\n    }\n  },\n\n  _handleMouseDown: function(event) {\n    this.mouseDownCount++;\n    var originalCount = this.mouseDownCount;\n\n    this.actionQueue.defer(this.holdTime, (function() {\n      if (this.mouseDownCount === originalCount &&\n          this.mouseUpCount === this.mouseDownCount - 1) {\n        this.isInClickAndHold = true;\n        this.handleClickAndHold(event);\n      }\n    }).bind(this));\n  },\n\n};\n\nmodule.exports = Component;\n",
    "var utils = require('./utils');\nvar Position = require('./geometry/Position');\nvar Component = require('./Component');\nvar Literal = require('./utils/Literal');\n\nfunction ComponentManager(options) {\n  this.document = options && options.document;\n  this.actionQueue = options && options.actionQueue;\n  this.componentServices = options && options.componentServices;\n}\n\nComponentManager.prototype = {\n  className: 'ComponentManager',\n\n  getConstructorArgs: function() {\n    return {\n      document: new Literal('global.document'),\n      actionQueue: this.actionQueue,\n      componentServices: this.componentServices,\n    };\n  },\n\n  insertComponent: function(options) {\n    options = Object.assign({\n      position: new Position({ topLeft: { x: 0, y: 0 }}),\n      pinTo: undefined,\n      class: Component,\n      constructorArgs: undefined,\n    }, options);\n\n    var component = new options.class(Object.assign(\n      {},\n      this.componentServices,\n      options.constructorArgs\n    ));\n\n    var element = this.document.createElement('div');\n    if (options.position) {\n      element.style = options.position.getStyle();\n    }\n    if (typeof options.pinTo === 'function') {\n      var positionTracker = this.actionQueue.periodically((function() {\n        element.style = options.pinTo().getStyle({\n          width: element.offsetWidth,\n          height: element.offsetHeight,\n        });\n      }).bind(this));\n      component.onRemove(positionTracker.cancel.bind(positionTracker));\n    }\n    this.document.body.insertBefore(element, this.document.body.firstChild);\n    component.attachTo(element);\n    return component;\n  },\n};\n\nmodule.exports = ComponentManager;\n",
    "var LEVEL_ORDER = [\n  'DEBUG',\n  'INFO',\n  'WARN',\n  'ERROR',\n];\n\nfunction Logger(name) {\n  this.name = name || 'Logger';\n}\n\nLogger.level = 'WARN';\nLogger.levels = {};\n\nLogger.prototype = {\n  debug: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'DEBUG', this.name].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  info: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'INFO', this.name].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  warn: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'WARN', this.name].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n  error: function(msg, objs) {\n    this._log.apply(this, [new Date().getTime(), 'ERROR', this.name].concat(Array.prototype.splice.call(arguments, 0)));\n  },\n\n  _log: function() {\n    var level = arguments[1];\n    var logLevel = Logger.levels[this.name] || Logger.level;\n    if (LEVEL_ORDER.indexOf(level) >= LEVEL_ORDER.indexOf(logLevel)) {\n      global.console.log.apply(global.console.log, arguments);\n    }\n  },\n};\n\n\nmodule.exports = Logger;\n",
    "var Logger = require('./Logger');\n\nvar LOG = new Logger('ModeSwitch');\n\nfunction ModeSwitch(opts) {\n  this.actionQueue = opts && opts.actionQueue;\n  this.timeout = (opts && opts.timeout) || 0;\n  this.modeStates = (opts && opts.initialStates) || {};\n  this.name = (opts && opts.name) || 'ModeSwitch';\n  this.currentMode = null;\n  this.resetModeFuture = null;\n  LOG.debug('Initialized ' + this.name, this);\n}\n\nModeSwitch.prototype = {\n  className: 'ModeSwitch',\n  getConstructorArgs: function() {\n    return {\n      actionQueue: this.actionQueue,\n      timeout: this.timeout,\n      initialStates: this.modeStates,\n      name: this.name,\n    };\n  },\n\n  enter: function(mode, fn) {\n    this._validate();\n    if (this._isPermitted(mode)) {\n      LOG.debug(this.name + ': Entering \\'' + mode + '\\'', this);\n      var state = (fn || function() {})();\n      this.modeStates[mode] = state;\n      this.currentMode = mode;\n      this._cancelModeReset();\n    } else {\n      LOG.debug(this.name + ': Not entering \\'' + mode + '\\';'\n                + ' active mode is ' + this.currentMode, this);\n    }\n    return this;\n  },\n\n  exit: function(mode, fn) {\n    this._validate();\n    if(this._isActive(mode)) {\n      LOG.debug(this.name + ': Exiting ' + mode, this);\n      (fn || function() {})(this.modeStates[mode]);\n      this._scheduleModeReset();\n    } else {\n      LOG.debug(this.name + ': Not exiting \\'' + mode + '\\';'\n                + ' active mode is ' + this.currentMode, this);\n    }\n    return this;\n  },\n\n  ifActive: function(callbackObj) {\n    var activeMode = this.currentMode || 'default';\n    var callback = callbackObj[activeMode];\n    if (callback) {\n      LOG.debug(this.name + ': Found callback for active mode', activeMode, callbackObj);\n      var modeState = this.modeStates[this.currentMode || 'default'];\n      callback(modeState);\n    } else {\n      LOG.debug(this.name + ': No callback for active mode', activeMode, callbackObj);\n    }\n    return this;\n  },\n\n  _isPermitted: function(mode) {\n    return !this.currentMode || this._isActive(mode);\n  },\n\n  _isActive: function(mode) {\n    return this.currentMode === mode;\n  },\n\n  _cancelModeReset: function() {\n    this.resetModeFuture && this.resetModeFuture.cancel();\n  },\n\n  _scheduleModeReset: function() {\n    var resetFunction = (function() {\n      delete this.modeStates[this.currentMode];\n      this.currentMode = null;\n    }).bind(this);\n\n    this._cancelModeReset();\n    if (this.timeout) {\n      this.resetModeFuture = this.actionQueue.defer(\n        this.timeout, resetFunction\n      );\n    } else {\n      resetFunction();\n    }\n  },\n\n  _validate: function() {\n    if(this.timeout && !this.actionQueue) {\n      throw new Error('action queue is required if a timeout is specified');\n    }\n  },\n};\n\nmodule.exports = ModeSwitch;\n",
    "var RED = '#db190f';\nvar ORANGE = '#f76402';\nvar YELLOW = '#fbff14';\nvar GREEN = '#28b92b';\nvar BLUE = '#2826b5';\nvar INDIGO = '#2980B9';\nvar VIOLET = '#8c28b7';\nvar NEON = '#00FF00';\n\nmodule.exports = {\n  RED: RED,\n  ORANGE: ORANGE,\n  YELLOW: YELLOW,\n  GREEN: GREEN,\n  BLUE: BLUE,\n  INDIGO: INDIGO,\n  VIOLET: VIOLET,\n  NEON: NEON,\n  RAINBOW: [\n    RED,\n    ORANGE,\n    YELLOW,\n    GREEN,\n    BLUE,\n    INDIGO,\n    VIOLET,\n  ],\n};\n",
    "var Component = require('../Component');\n\nfunction BlockText(opts) {\n  Component.apply(this, arguments);\n  this.text = opts && opts.text;\n}\n\nBlockText.prototype = Object.assign(new Component(), {\n  className: 'BlockText',\n\n  getGeneratedMarkup: function() {\n    return this.text && ('<p>'  + this.text + '</p>');\n  },\n});\n\nmodule.exports = BlockText;\n",
    "var Component = require('../Component');\nvar utils = require('../utils');\nvar Logger = require('../Logger');\n\nvar LOG = new Logger('GraphComponent');\n\n\nfunction GraphComponent(opts) {\n  Component.apply(this, arguments);\n  this.adapter = opts && opts.adapter;\n  this.editMode = opts && opts.editMode;\n  this.graph = opts && opts.graph;\n  this.width = opts && opts.width;\n  this.height = opts && opts.height;\n  this.nodeAreaFuzzFactor = opts.nodeAreaFuzzFactor;\n}\n\n\nGraphComponent.prototype = Object.assign(new Component(), {\n  className: 'GraphComponent',\n\n  doAttach: function(targetElement) {\n    this.graph.initialize({\n      element: targetElement,\n      width: this.width,\n      height: this.height,\n    });\n  },\n\n  handleClick: function(event) {\n    var clickTarget = this.adapter.getClickTarget(\n      event, this.nodeAreaFuzzFactor\n    );\n\n    this.editMode.perform({\n      ifActive: (function(currentlyEditedNode) {\n        if (clickTarget.isNode() && clickTarget.id !== currentlyEditedNode.id) {\n          this.graph.addEdge(currentlyEditedNode, clickTarget);\n       } else {\n          this.editMode.deactivate();\n        }\n      }).bind(this),\n\n      ifNotActive: (function() {\n        if (clickTarget.isNode()) {\n          this.graph.changeColor(clickTarget);\n        } else {\n          this.graph.addNode();\n        }\n      }).bind(this)\n    });\n  },\n\n  handleClickAndHold: function(event) {\n    var clickTarget = this.adapter.getClickTarget(\n      event, this.nodeAreaFuzzFactor\n    );\n    if (clickTarget.isNode()) {\n      this.editMode.activate(clickTarget);\n    }\n  },\n\n  reset: function() {\n    this.graph.reset();\n    this.editMode.deactivate();\n  },\n\n  _validateOptions: function() {\n    Component.prototype._validateOptions.call(this, arguments);\n    if (!this.adapter) {\n      throw new Error('adapter is required');\n    }\n    if (!this.editMode) {\n      throw new Error('edit mode is required');\n    }\n    if (!this.graph) {\n      throw new Error('graph is required');\n    }\n  },\n});\n\nmodule.exports = GraphComponent;\n",
    "var Component = require('../Component');\n\nfunction ResetButton(options) {\n  Component.apply(this, arguments);\n  if (options) {\n    this.resettables = options.resettables;\n  } else {\n    this.resettables = [];\n  }\n\n}\n\nResetButton.prototype = Object.assign(new Component(), {\n  className: 'ResetButton',\n\n  handleClick: function(event) {\n    this.resettables.forEach(function(resettable) {\n      resettable.reset();\n    });\n  },\n});\n\nmodule.exports = ResetButton;\n",
    "var Component = require('../Component');\n\nfunction TextBox(options) {\n  Component.apply(this, arguments);\n  this.initialText = (options && options.text) || '';\n  this.onSave = (options && options.onSave) || function() {};\n}\n\nTextBox.prototype = Object.assign(new Component(), {\n  className: 'TextBox',\n\n  getGeneratedMarkup: function() {\n    return '<input type=\"text\"' +\n    ' value=\"' + this.initialText + '\"' +\n    '></input>';\n  },\n\n  getText: function() {\n    return this.element.getElementsByTagName('input')[0].value;\n  },\n\n  handleEnter: function(event) {\n    this.onSave();\n  },\n});\n\nmodule.exports = TextBox;\n",
    "function BoundingBox(dimensions) {\n  this.dimensions = dimensions || {\n    left: 0,\n    top: 0,\n    right: 0,\n    bottom: 0,\n  };\n}\n\nBoundingBox.prototype = {\n  className: 'BoundingBox',\n\n  getConstructorArgs: function() { return this.dimensions; },\n\n  expandBy: function(factor) {\n    return new BoundingBox({\n      left: this.dimensions.left - this.getWidth()*factor,\n      right: this.dimensions.right + this.getWidth()*factor,\n      top: this.dimensions.top - this.getHeight()*factor,\n      bottom: this.dimensions.bottom + this.getHeight()*factor,\n    });\n  },\n\n  translate: function(vector) {\n    return new BoundingBox({\n      left: this.dimensions.left + vector.x,\n      right: this.dimensions.right + vector.x,\n      top: this.dimensions.top + vector.y,\n      bottom: this.dimensions.bottom + vector.y,\n    });\n  },\n\n  contains: function(point) {\n    return this.dimensions.left <= point.x && point.x <= this.dimensions.right &&\n           this.dimensions.top <= point.y && point.y <= this.dimensions.bottom;\n\n  },\n\n  getCenter: function() {\n    return {\n      x: this.dimensions.left + this.getWidth() / 2,\n      y: this.dimensions.top + this.getHeight() / 2,\n    };\n  },\n\n  getTopLeft: function() {\n    return {\n      x: this.dimensions.left,\n      y: this.dimensions.top,\n    };\n  },\n\n\n  getTopRight: function() {\n    return {\n      x: this.dimensions.right,\n      y: this.dimensions.top,\n    };\n  },\n\n\n  getBottomLeft: function() {\n    return {\n      x: this.dimensions.left,\n      y: this.dimensions.bottom,\n    };\n  },\n\n  getBottomRight: function() {\n    return {\n      x: this.dimensions.right,\n      y: this.dimensions.bottom,\n    };\n  },\n\n  getWidth: function() {\n    return this.dimensions.right - this.dimensions.left;\n  },\n\n  getHeight: function() {\n    return this.dimensions.bottom - this.dimensions.top;\n  },\n\n};\n\nmodule.exports = BoundingBox;\n",
    "var utils = require('../utils');\n\nfunction Position(opts) {\n  /* opts -\n   * {\n    topLeft: { x: 0, y: 0 },\n    topRight: undefined,\n    bottomLeft: undefined,\n    bottomRight: undefined,\n    }\n   */\n  if (!utils.isOneValuedObject(opts)) {\n    throw new Error('invalid position object ' + opts);\n  }\n\n  Object.assign(this, opts);\n}\n\n\nPosition.prototype = {\n  className: 'Position',\n  getConstructorArgs: function() { return this; },\n\n  getStyle: function(opts) {\n    opts = Object.assign({\n      width: 0,\n      height: 0,\n    }, opts);\n\n    if (this.topLeft) {\n        return 'position: absolute;' +\n        ' left: ' + this.topLeft.x + ';' +\n        ' top: ' + this.topLeft.y + ';';\n    } else if (this.topRight) {\n      return 'position: absolute;' +\n        ' left: ' + (this.topRight.x - opts.width) + ';' +\n        ' top: ' + this.topRight.y + ';';\n    } else if (this.bottomLeft) {\n      return 'position: absolute;' +\n        ' left: ' + this.bottomLeft.x + ';' +\n        ' top: ' + (this.bottomLeft.y - opts.height) + ';';\n    } else if (this.bottomRight) {\n      return 'position: absolute;' +\n        ' left: ' + (this.bottomRight.x  - opts.width)+ ';' +\n        ' top: ' + (this.bottomRight.y - opts.height) + ';';\n    } else {\n      throw new Error('invalid position object: ' + this);\n    }\n  },\n};\n\nmodule.exports = Position;\n",
    "var utils = require('../utils');\n\nfunction ColorChanger() {\n\n}\n\nColorChanger.prototype = {\n  className: 'ColorChanger',\n  getConstructorArgs: function() { return {}; },\n\n  setColor: function(opts) {\n    var adapter = utils.requireNonNull(opts, 'adapter');\n    var state = utils.requireNonNull(opts, 'state');\n    var node = utils.requireNonNull(opts, 'node');\n    var color = utils.requireNonNull(opts, 'color');\n\n    adapter.setNodeColor(node, color);\n    state.persistNode({ id: node.id, color: color });\n  },\n};\n\nmodule.exports = ColorChanger;\n",
    "var utils = require('../utils');\n\nfunction EdgeCreator() {\n\n}\n\nEdgeCreator.prototype = {\n  className: 'EdgeCreator',\n  getConstructorArgs: function() { return {}; },\n\n  addEdge: function(opts) {\n    var adapter = utils.requireNonNull(opts, 'adapter');\n    var state = utils.requireNonNull(opts, 'state');\n    var source = utils.requireNonNull(opts, 'source');\n    var target = utils.requireNonNull(opts, 'target');\n    var edgeDistance = opts.edgeDistance;\n\n    adapter.addEdge({\n      source: source,\n      target: target,\n      distance: edgeDistance,\n    });\n    state.persistEdge(source.id, target.id);\n  },\n\n};\n\nmodule.exports = EdgeCreator;\n",
    "var colors = require('../colors');\nvar utils = require('../utils');\nvar Logger = require('../Logger');\nvar NodeCreator = require('./NodeCreator');\nvar EdgeCreator = require('./EdgeCreator');\nvar ColorChanger = require('./ColorChanger');\n\nvar LOG = new Logger('Graph');\n\nfunction Graph(opts) {\n  debugger;\n  this.state = opts && opts.state;\n  this.adapter = opts && opts.adapter;\n  this.actionQueue = opts && opts.actionQueue;\n  this.labelSet = opts && opts.labelSet;\n  this.nodeCreator = (opts && opts.nodeCreator) || new NodeCreator();\n  this.edgeCreator = (opts && opts.edgeCreator) || new EdgeCreator();\n  this.colorChanger = (opts && opts.colorChanger) || new ColorChanger();\n\n  this.colorChoices = (opts && opts.colorChoices) || utils.startingAt(colors.RAINBOW, colors.INDIGO);\n  this.nodeSize = opts && opts.nodeSize;\n  this.edgeDistance = opts && opts.edgeDistance;\n  this.initialNodes = (opts && opts.initialNodes) || [];\n  this.initialEdges = (opts && opts.initialEdges) || [];\n  this.constructorArgs = opts;\n}\n\nGraph.prototype = {\n  className: 'Graph',\n\n  getConstructorArgs: function() {\n    return Object.assign({\n      initialNodes: this.state.retrievePersistedNodes(),\n      initialEdges: this.state.retrievePersistedEdges(),\n    }, this.constructorArgs);\n  },\n\n  initialize: function(opts) {\n    this._validate();\n    LOG.debug('initializing graph', this);\n\n    this.adapter.initialize(\n      opts.element,\n      utils.optional({\n        width: opts.width,\n        height: opts.height,\n        nodes: this.initialNodes.map((function(n) {\n          return utils.optional({\n            id: n.id,\n            color: n.color || this.colorChoices[0],\n            label: '',\n            size: this.nodeSize,\n          }, { force: ['id', 'label'] });\n        }).bind(this)),\n        edges: this.initialEdges,\n        edgeDistance: this.edgeDistance,\n      })\n    );\n    this.actionQueue.defer((function() {\n      LOG.debug('initializing label set');\n      this.labelSet.initialize(\n        this.initialNodes.map((function(n) {\n          return {\n            node: this.adapter.getNode(n.id),\n            label: n.label,\n          };\n        }).bind(this))\n      );\n    }).bind(this));\n  },\n\n  addNode: function() {\n    this.nodeCreator.addNode({\n      state: this.state,\n      adapter: this.adapter,\n      color: this.colorChoices[0],\n      nodeSize: this.nodeSize,\n    });\n  },\n\n  changeColor: function(node) {\n    var colorIndex = this._getNextColorIndex(node);\n    var newColor = this.colorChoices[colorIndex];\n    this.colorChanger.setColor({\n      adapter: this.adapter,\n      state: this.state,\n      node: node,\n      color: newColor,\n    });\n  },\n\n  addEdge: function(source, target) {\n    this.edgeCreator.addEdge({\n      source: source,\n      target: target,\n      adapter: this.adapter,\n      state: this.state,\n      edgeDistance: this.edgeDistance,\n    });\n },\n\n  reset: function() {\n    LOG.debug('resetting');\n    this.adapter.performInBulk((function() {\n      this.state.retrievePersistedNodes().forEach((function(node) {\n        this.adapter.removeNode(node);\n      }).bind(this));\n    }).bind(this));\n\n    this.state.reset();\n    this.labelSet.closeAll();\n  },\n\n  _getNextColorIndex: function(node) {\n    var colorIndex = this.colorChoices.indexOf(node.color);\n    return (colorIndex + 1) % this.colorChoices.length;\n  },\n\n  _validate: function() {\n    if (!this.state) {\n      throw new Error('state is required');\n    }\n    if (!this.adapter) {\n      throw new Error('adapter is required');\n    }\n    if (!this.actionQueue) {\n      throw new Error('actionQueue is required');\n    }\n    if (!this.labelSet) {\n      throw new Error('labelSet is required');\n    }\n    if (!this.nodeCreator) {\n      throw new Error('nodeCreator is required');\n    }\n    if (!this.edgeCreator) {\n      throw new Error('edgeCreator is required');\n    }\n  },\n};\n\nmodule.exports = Graph;\n",
    "var graphelements = require('./graphelements');;\nvar utils = require('../utils');\nvar BoundingBox = require('../geometry/BoundingBox');\nvar Literal = require('../utils/Literal');\nvar Logger = require('../Logger');\n\nvar LOG = new Logger('GreulerAdapter');\n\n\nfunction GreulerAdapter(opts) {\n  this.greuler = opts && opts.greuler;\n  this.isInBulkOperation = false;\n}\n\n\nGreulerAdapter.prototype = {\n  className: 'GreulerAdapter',\n\n  getConstructorArgs: function() {\n    return { greuler: new Literal('global.greuler') };\n  },\n\n  initialize: function(targetNode, options) {\n    options = options || {};\n    this.instance = this.greuler(utils.optional({\n      target: '#' + targetNode.id,\n      width: options.width,\n      height: options.height,\n      data: utils.optional({\n        nodes: (options.nodes && options.nodes.map(this._translateNodeObj)),\n        links: options.edges,\n        linkDistance: options.edgeDistance && function() {\n          return options.edgeDistance;\n        },\n      }),\n    })).update();\n    this.graph = this.instance.graph;\n  },\n\n  addNode: function(node) {\n    var result = this.graph.addNode(this._translateNodeObj(node));\n    this._updateInstance();\n  },\n\n  removeNode: function(node) {\n    var result = this.graph.removeNode(this._translateNodeObj(node));\n    this._updateInstance();\n  },\n\n  addEdge: function(options) {\n    var result = this.graph.addEdge(utils.optional({\n      source: options.source.id,\n      target: options.target.id,\n      linkDistance: options.distance,\n    }, { force: ['source', 'target'] }));\n    this._updateInstance();\n  },\n\n  setNodeColor: function(target, color) {\n    if (target.domElement) {\n      target.domElement.setAttribute('fill', color);\n    } else if (target.id) {\n      var node = this.graph.getNode({ id: target.id });\n      this._getDomElement(node).setAttribute('fill', color);\n    } else {\n      LOG.error('Got unexpected target node', target);\n    }\n  },\n\n  getClickTarget: function(event, nodeAreaFuzzFactor) {\n    return this._getTargetNode(event, nodeAreaFuzzFactor) || graphelements.NONE;\n  },\n\n  getNode: function(nodeId) {\n    LOG.debug('retrieving node', nodeId);\n    return this.getNodes(function(n) { return n.id === nodeId; })[0];\n  },\n\n  getNodes: function(filter) {\n    filter = filter || function() { return true; };\n    return this.graph.getNodesByFn(filter).map((function(node) {\n      var domElement = this._getDomElement(node);\n      return new graphelements.Node({\n        id: node.id,\n        realNode: node,\n        domElement: domElement,\n        color: domElement.getAttribute('fill'),\n        getCurrentBoundingBox: this._getBoundingBox.bind(this, node),\n      });\n    }).bind(this));\n  },\n\n  performInBulk: function(actions) {\n    this.isInBulkOperation = true;\n    actions(this);\n    this.isInBulkOperation = false;\n    this._updateInstance();\n  },\n\n  _translateNodeObj: function(node) {\n    return utils.optional({\n      id: node.id,\n      fill: node.color,\n      label: node.label || '',\n      r: node.size,\n    }, { force: ['id', 'label'] });\n  },\n\n  _getDomElement: function(node) {\n    LOG.debug('retrieving dom element for node: ' + node.index, this.instance);\n    var childNodes = this.instance.nodeGroup[0][0].childNodes;\n    LOG.debug(childNodes);\n    return childNodes[node.index].getElementsByTagName('circle')[0];\n  },\n\n  _getTargetNode: function(event, nodeAreaFuzzFactor) {\n    nodeAreaFuzzFactor = nodeAreaFuzzFactor || 0;\n    var point = {\n      x: event.clientX,\n      y: event.clientY,\n    };\n    var matchingNodes = this.getNodes((function(node) {\n      return this._getBoundingBox(node)\n        .expandBy(nodeAreaFuzzFactor)\n        .contains(point);\n    }).bind(this));\n\n    if (matchingNodes && matchingNodes.length) {\n      matchingNodes.sort(function(a, b) {\n        var distanceToA = utils.distance(a.getCenter(), point);\n        var distanceToB = utils.distance(b.getCenter(), point);\n        return distanceToA - distanceToB;\n      });\n      return matchingNodes[0];\n    } else {\n      return undefined;\n    }\n  },\n\n  _updateInstance: function() {\n    if (!this.isInBulkOperation) {\n      this.instance = this.instance.update();\n    }\n  },\n\n  _getBoundingBox: function(node) {\n    var graphElementBounds = this.instance.root[0][0].getBoundingClientRect();\n    return new BoundingBox({\n      left: node.bounds.x,\n      right: node.bounds.X,\n      top: node.bounds.y,\n      bottom: node.bounds.Y,\n    })\n    .translate({\n      x: graphElementBounds.left,\n      y: graphElementBounds.top\n    });\n  },\n};\n\nmodule.exports = GreulerAdapter;\n",
    "function NoOpColorChanger() {\n\n}\n\nNoOpColorChanger.prototype = {\n  className: 'NoOpColorChanger',\n\n  getConstructorArgs: function() { return {}; },\n  setColor: function() {},\n};\n\nmodule.exports = NoOpColorChanger;\n",
    "function NoOpEdgeCreator() {\n\n}\n\nNoOpEdgeCreator.prototype = {\n  className: 'NoOpEdgeCreator',\n  getConstructorArgs: function() { return {}; },\n\n  addEdge: function() {},\n\n};\n\nmodule.exports = NoOpEdgeCreator;\n",
    "function NoOpNodeCreator() {\n\n}\n\nNoOpNodeCreator.prototype = {\n  className: 'NoOpNodeCreator',\n  getConstructorArgs: function() { return {}; },\n  addNode: function() {},\n};\n\nmodule.exports = NoOpNodeCreator;\n",
    "var utils = require('../utils');\n\nfunction NodeCreator() {\n}\n\nNodeCreator.prototype = {\n  className: 'NodeCreator',\n  getConstructorArgs: function() { return {}; },\n\n  addNode: function(opts) {\n    var state = utils.requireNonNull(opts, 'state');\n    var adapter = utils.requireNonNull(opts, 'adapter');\n    var color = utils.requireNonNull(opts, 'color');\n    var nodeSize = opts.nodeSize;\n\n    var nodeId = state.persistNode({\n      color: color,\n    });\n    var node = utils.optional({\n      id: nodeId,\n      color: color,\n      label: '',\n      size: nodeSize,\n    }, { force: ['id', 'label'] });\n    adapter.addNode(node);\n  },\n};\n\nmodule.exports = NodeCreator;\n",
    "function GraphElement(options) {\n  if (options) {\n    this.id = options.id;\n    this.domElement = options.domElement;\n  }\n}\n\nGraphElement.prototype = {\n  isNode: function() {\n    return false;\n  },\n  isEdge: function() {\n    return false;\n  },\n};\n\nfunction Node(options) {\n  GraphElement.apply(this, arguments);\n  if (options) {\n    this.realNode = options.realNode;\n    this.color = options.color;\n    this.getCurrentBoundingBox = options.getCurrentBoundingBox;\n  }\n}\n\nNode.prototype = Object.assign(new GraphElement(), {\n  isNode: function() { return true; },\n\n  getCenter: function() {\n    return this.getCurrentBoundingBox().getCenter();\n  },\n\n  getTopLeft: function() {\n    return this.getCurrentBoundingBox().getTopLeft();\n  },\n\n  getTopRight: function() {\n    return this.getCurrentBoundingBox().getTopRight();\n  },\n\n  getBottomLeft: function() {\n    return this.getCurrentBoundingBox().getBottomLeft();\n  },\n\n  getBottomRight: function() {\n    return this.getCurrentBoundingBox().getBottomRight();\n  },\n});\n\n\nfunction Edge() {\n  GraphElement.apply(this, arguments);\n}\n\nEdge.prototype = Object.assign(new GraphElement(), {\n  isEdge: function() { return true; },\n});\n\nfunction None() {\n  GraphElement.apply(this, arguments);\n}\n\nNone.prototype = Object.assign(new GraphElement(), {\n\n});\n\nmodule.exports = {\n  Node: Node,\n  Edge: Edge,\n  NONE: new None(),\n};\n",
    "\nvar GreulerAdapter = require('./GreulerAdapter');\nvar ColorChanger = require('./ColorChanger');\nvar EdgeCreator = require('./EdgeCreator');\nvar NodeCreator = require('./NodeCreator');\nvar NoOpColorChanger = require('./NoOpColorChanger');\nvar NoOpEdgeCreator = require('./NoOpEdgeCreator');\nvar NoOpNodeCreator = require('./NoOpNodeCreator');\nvar Graph = require('./Graph');\n\nvar DisallowedEditMode = require('../modes/DisallowedEditMode');\nvar EditMode = require('../modes/EditMode');\nvar NonAnimatingEditMode = require('../modes/NonAnimatingEditMode');\n\nvar EmptyLabelSet = require('../labels/EmptyLabelSet');\nvar NodeLabelSet = require('../labels/NodeLabelSet');\n\nvar GraphComponent = require('../components/GraphComponent');\n\nvar Animator = require('../Animator');\nvar ComponentManager = require('../ComponentManager');\nvar utils = require('../utils');\nvar Logger = require('../Logger');\n\nvar LOG = new Logger('graphfactory');\n\nvar SMALL_SCREEN_THRESHOLD = 700;\n\nmodule.exports = {\n  newGraph: function(opts) {\n    opts = Object.assign({\n      immutable: false,\n      allowAddNodes: true,\n      allowAddEdges: true,\n      allowChangeColors: true,\n      allowLabels: true,\n    }, opts);\n    LOG.debug('instantiating graph', opts);\n\n\n    return new Graph({\n      actionQueue: utils.requireNonNull(opts, 'actionQueue'),\n      adapter: utils.requireNonNull(opts, 'adapter'),\n      colorChoices: opts.colorChoices,\n      colorChanger: this._getColorChanger(opts),\n      edgeCreator: this._getEdgeCreator(opts),\n      edgeDistance: opts.edgeDistance,\n      initialNodes: opts.initialNodes,\n      initialEdges: opts.initialEdges,\n      labelSet: this._getLabelSet(opts),\n      nodeCreator: this._getNodeCreator(opts),\n      nodeSize: opts.nodeSize,\n      state: utils.requireNonNull(opts, 'state'),\n    });\n  },\n\n  /**\n   * document: global.document,\n   * screen: global.screen,\n   * window: window,\n   * size: 'fullscreen'|'large'|'wide'|'small'|undefined\n   * adapter: new GreulerAdapter({ greuler: global.greuler }),\n   * actionQueue: actionQueue,\n   * state: state,\n   * nodeAreaFuzzFactor: 0.1,\n   * alternateInterval: 250,\n   * immutable: boolean,\n   * allowAddNodes: boolean,\n   * allowAddEdges: boolean,\n   * allowChangeColors: boolean,\n   * allowEdit: boolean,\n   * allowLabels: boolean,\n   * colorChoices: Array<String>\n   * initialNodes: Array<Node>\n   * initialEdges: Array<Edge>\n   */\n  newGraphComponent: function(opts) {\n    opts = Object.assign({\n      immutable: false,\n      allowAddNodes: true,\n      allowAddEdges: true,\n      allowChangeColors: true,\n      allowLabels: true,\n      allowEdit: true,\n      nodeAreaFuzzFactor: 0.1,\n      alternateInterval: 250,\n      size: 'large',\n    }, opts);\n    LOG.debug('instantiating graph component', opts);\n    var sizing = this._getSizing(opts);\n\n    var labelSet = this._getLabelSet(opts);\n\n    return new GraphComponent(Object.assign({\n        graph: this.newGraph(Object.assign({\n          labelSet: labelSet,\n          nodeSize: sizing.nodeSize,\n          edgeDistance: sizing.edgeDistance,\n        }, opts)),\n        adapter: utils.requireNonNull(opts, 'adapter'),\n        editMode: this._getEditMode(opts, labelSet),\n        width: sizing.width,\n        height: sizing.height,\n        nodeAreaFuzzFactor: opts.nodeAreaFuzzFactor,\n      },\n      this._getComponentServices(opts)\n    ));\n  },\n\n  _newComponentManager: function(opts) {\n    return new ComponentManager({\n      actionQueue: utils.requireNonNull(opts, 'actionQueue'),\n      componentServices: this._getComponentServices(opts),\n      document: utils.requireNonNull(opts, 'document'),\n    });\n  },\n\n  _getComponentServices: function(opts) {\n    var actionQueue = utils.requireNonNull(opts, 'actionQueue');\n    return { actionQueue: actionQueue };\n  },\n\n  _getColorChanger: function(opts) {\n    if (opts.immutable || !opts.allowChangeColors) {\n      return new NoOpColorChanger();\n    } else {\n      return new ColorChanger();\n    }\n  },\n\n  _getEdgeCreator: function(opts) {\n    if (opts.immutable || !opts.allowAddEdges) {\n      return new NoOpEdgeCreator();\n    } else {\n      return new EdgeCreator();\n    }\n  },\n\n  _getNodeCreator: function(opts) {\n    if (opts.immutable || !opts.allowAddNodes) {\n      return new NoOpNodeCreator();\n    } else {\n      return new NodeCreator();\n    }\n  },\n\n  _getEditMode: function(opts, labelSet) {\n    if (opts.immutable || !opts.allowEdit) {\n      return new DisallowedEditMode();\n    } else if (!opts.allowAddEdges) {\n      return new NonAnimatingEditMode({\n        adapter: utils.requireNonNull(opts, 'adapter'),\n        labelSet: labelSet,\n        alternateInterval: opts.alternateInterval,\n      });\n    } else {\n      return new EditMode({\n        adapter: utils.requireNonNull(opts, 'adapter'),\n        animator: new Animator({ actionQueue: utils.requireNonNull(opts, 'actionQueue') }),\n        labelSet: labelSet,\n        alternateInterval: opts.alternateInterval,\n      });\n    }\n  },\n\n  _getLabelSet: function(opts) {\n    if (!opts.allowLabels) {\n      return new EmptyLabelSet();\n    } else {\n      return new NodeLabelSet({\n        componentManager: opts.componentManager || this._newComponentManager(opts),\n        state: opts.state,\n      });\n    }\n  },\n\n  _getSizing: function(opts) {\n    var customSize = opts.width && opts.height;\n    if (!customSize && opts.size == 'fullscreen') {\n      return this._getFullScreenSizing(opts);\n    } else if (!customSize && opts.size === 'large') {\n      return this._getLargeSizing(opts);\n    } else if (!customSize && opts.size === 'wide') {\n      return this._getWideSizing(opts);\n    } else if (!customSize && opts.size === 'small') {\n      return this._getSmallSizing(opts);\n    } else {\n      return {\n        width: utils.requireNonNull(opts, 'width'),\n        height: utils.requireNonNull(opts, 'height'),\n        nodeSize: opts.nodeSize || 10,\n        edgeDistance: opts.edgeDistance || 100,\n      };\n    }\n  },\n\n  _getFullScreenSizing: function(opts) {\n    var window = utils.requireNonNull(opts, 'window');\n    var screen = utils.requireNonNull(opts, 'screen');\n    var screenWidth = (window.innerWidth > 0) ? window.innerWidth : screen.width;\n    var screenHeight = (window.innerHeight > 0) ? window.innerHeight : screen.height;\n    return {\n      width: screenWidth,\n      height: screenHeight,\n      nodeSize: this._getNodeSize(screenWidth, screenHeight),\n      edgeDistance: this._getEdgeDistance(screenWidth),\n    };\n  },\n\n  _getLargeSizing: function(opts) {\n    var window = utils.requireNonNull(opts, 'window');\n    var screen = utils.requireNonNull(opts, 'screen');\n    var screenWidth = (window.innerWidth > 0) ? window.innerWidth : screen.width;\n    var screenHeight = (window.innerHeight > 0) ? window.innerHeight : screen.height;\n    var width = screenWidth > SMALL_SCREEN_THRESHOLD ? 700 : 300;\n    return {\n      width: width,\n      height: opts.height || width,\n      nodeSize: this._getNodeSize(screenWidth, screenHeight),\n      edgeDistance: this._getEdgeDistance(screenWidth),\n    };\n  },\n\n  _getWideSizing: function(opts) {\n    var window = utils.requireNonNull(opts, 'window');\n    var screen = utils.requireNonNull(opts, 'screen');\n    var screenWidth = (window.innerWidth > 0) ? window.innerWidth : screen.width;\n    var screenHeight = (window.innerHeight > 0) ? window.innerHeight : screen.height;\n    var width = screenWidth < 1000 ? screenWidth : 1000;\n    return {\n      width: width,\n      height: opts.height || width / 2,\n      nodeSize: this._getNodeSize(screenWidth, screenHeight),\n      edgeDistance: this._getEdgeDistance(screenWidth),\n    };\n  },\n\n\n  _getSmallSizing: function(opts) {\n    var window = utils.requireNonNull(opts, 'window');\n    var screen = utils.requireNonNull(opts, 'screen');\n    var screenWidth = (window.innerWidth > 0) ? window.innerWidth : screen.width;\n    var screenHeight = (window.innerHeight > 0) ? window.innerHeight : screen.height;\n    return {\n      width: 300,\n      height: opts.height || 500,\n      nodeSize: this._getNodeSize(screenWidth, screenHeight),\n      edgeDistance: this._getEdgeDistance(screenWidth),\n    };\n  },\n\n  _getNodeSize: function(screenWidth, screenHeight) {\n    return screenWidth > SMALL_SCREEN_THRESHOLD ? 10 : (Math.min(screenWidth, screenHeight) / 18);\n  },\n\n  _getEdgeDistance: function(screenWidth) {\n    return screenWidth > SMALL_SCREEN_THRESHOLD ? 100 : 200;\n  },\n};\n",
    "var ModeSwitch = require('../ModeSwitch');\nvar BlockText = require('../components/BlockText');\nvar TextBox = require('../components/TextBox');\nvar Logger = require('../Logger');\n\nvar LOG = new Logger('EditableLabel');\n\nfunction EditableLabel(opts) {\n  if (opts) {\n    this.componentManager = opts.componentManager;\n    this.text = opts.text;\n    this.pinTo = opts.pinTo;\n    this.modeSwitch = new ModeSwitch({\n      name: 'EditableLabel({ text: \\'' + this.text + '\\'})'\n    });\n    this.onChange = opts.onChange || function() {};\n  }\n}\n\nEditableLabel.prototype = {\n  className: 'EditableLabel',\n\n  getConstructorArgs: function() {\n    return {\n      componentManager: this.componentManager,\n      text: this.text,\n      pinTo: this.pinTo,\n      onChange: this.onChange,\n    };\n  },\n\n  display: function() {\n    LOG.debug('displaying text', this.text);\n    this._validate();\n\n    this.modeSwitch.exit('edit', (function(editState) {\n      this.text = editState.component.getText();\n      editState.component.remove();\n      LOG.debug('got text from input component', this.text);\n    }).bind(this))\n    .exit('display', function(displayState) { displayState.component.remove(); });\n\n    if (this.text) {\n      this.modeSwitch.enter('display', (function() {\n        var component = this.componentManager.insertComponent({\n          class: BlockText,\n          constructorArgs: { text: this.text },\n          pinTo: this.pinTo,\n        });\n        this.onChange(this.text);\n        LOG.debug('EditableLabel: displaying component with text', this.text);\n        return { component: component };\n      }).bind(this));\n    }\n    return this;\n  },\n\n  edit: function() {\n    LOG.debug('editing text', this.text);\n    this._validate();\n    this.modeSwitch.exit('display', (function(displayState) {\n      displayState.component.remove();\n      LOG.debug('closed display component');\n    }).bind(this))\n    .exit('edit', function(editState) { editState.component.remove(); });\n\n    this.modeSwitch.enter('edit', (function() {\n       var component = this.componentManager.insertComponent({\n        class: TextBox,\n        constructorArgs: {\n          text: this.text,\n          onSave: this.display.bind(this),\n        },\n        pinTo: this.pinTo,\n      });\n      LOG.debug('opened edit component');\n      return { component: component };\n    }).bind(this));\n    return this;\n  },\n\n  _validate: function() {\n    if(!this.componentManager) {\n      throw new Error('componentManager is required');\n    }\n    if(!this.modeSwitch) {\n      throw new Error('modeSwitch is required');\n    }\n  },\n\n  remove: function() {\n    LOG.debug('removing', this);\n    this.modeSwitch\n      .exit('display', function(displayState) {\n        displayState.component.remove();\n        LOG.debug('closed display component');\n      })\n      .exit('edit', function(editState) {\n        editState.component.remove();\n        LOG.debug('closed edit component');\n      }) ;\n    return this;\n  },\n\n  _closeComponent: function(state) {\n    state.component.remove();\n  },\n};\n\nEditableLabel.Factory = {\n  create: function(opts) { return new EditableLabel(opts); },\n\n};\nmodule.exports = EditableLabel;\n",
    "function EmptyLabelSet() {\n\n}\n\nEmptyLabelSet.prototype = {\n  className: 'EmptyLabelSet',\n  getConstructorArgs: function() { return {}; },\n\n  initialize: function() {},\n  edit: function() {},\n  display: function() {},\n  closeAll: function() {},\n};\n\nmodule.exports = EmptyLabelSet;\n",
    "var Position = require('../geometry/Position');\nvar EditableLabel = require('./EditableLabel');\nvar Logger = require('../Logger');\n\nvar LOG = new Logger('NodeLabelSet');\n\nfunction NodeLabelSet(opts) {\n  this.componentManager = opts && opts.componentManager;\n  this.state = opts && opts.state;\n  this.editableLabelFactory = (opts && opts.editableLabelFactory) || EditableLabel.Factory;\n  this.labels = {};\n}\n\nNodeLabelSet.prototype = {\n  className: 'NodeLabelSet',\n  getConstructorArgs: function() {\n    return {\n      componentManager: this.componentManager,\n      state: this.state,\n    };\n  },\n\n  initialize: function(initialData) {\n    LOG.debug('initializing', initialData);\n    initialData\n      .filter(function(o) { return !!o.label; })\n      .forEach((function(o) {\n        var label = this._createLabel(o.node, o.label);\n        this.labels[o.node.id] = label;\n        label.display();\n      }).bind(this));\n  },\n\n  edit: function(node) {\n    LOG.debug('editing label for node ' + node.id);\n    this._getOrCreateLabel(node).edit();\n  },\n\n  display: function(node) {\n    LOG.debug('displaying label for node ' + node.id);\n    this._getOrCreateLabel(node).display();\n  },\n\n  closeAll: function() {\n    LOG.debug('closing all labels', this.labels);\n    Object.values(this.labels).forEach(function(label) {\n      label.remove();\n    });\n    this.labels = {};\n  },\n\n  _getOrCreateLabel: function(node) {\n    var label;\n    if (this.labels[node.id]) {\n      label = this.labels[node.id];\n      LOG.info('reusing existing label for node ' + node.id, label);\n    } else {\n      label = this._createLabel(node);\n      this.labels[node.id] = label;\n      LOG.info('created new label for node ' + node.id, label);\n    }\n    return label;\n  },\n\n  _createLabel: function(node, label) {\n    LOG.debug('Creating label', node);\n    return this.editableLabelFactory.create({\n      text: label,\n      componentManager: this.componentManager,\n      pinTo: function() {\n        return new Position({\n          bottomRight: node.getCurrentBoundingBox().getTopLeft(),\n        });\n      },\n      onChange: (function(text) {\n        LOG.debug('saving label', node, text);\n        this.state.persistNode({ id: node.id, label: text });\n      }).bind(this),\n    });\n  },\n\n  _validate: function() {\n    if (!this.componentManager) {\n      throw new Error('componentManager is required');\n    }\n    if (!this.state) {\n      throw new Error('state is required');\n    }\n  },\n};\n\nmodule.exports = NodeLabelSet;\n",
    "var EditMode = require('./EditMode');\n\nfunction DisallowedEditMode() {\n  EditMode.apply(this, arguments);\n}\n\nDisallowedEditMode.prototype = Object.assign(new EditMode(), {\n  className: 'DisallowedEditMode',\n\n  activate: function() {},\n  _validate: function() {},\n});\n\nmodule.exports = DisallowedEditMode;\n",
    "var ModeSwitch = require('../ModeSwitch');\nvar colors = require('../colors');\nvar Logger = require('../Logger');\n\nvar LOG = new Logger('EditMode');\n\n\nfunction EditMode(opts) {\n  this.adapter = opts && opts.adapter;\n  this.animator = opts && opts.animator;\n  this.alternateInterval = (opts && opts.alternateInterval) || 250;\n  this.labelSet = opts && opts.labelSet;\n  this.modeSwitch = (opts && opts.modeSwitch) || new ModeSwitch({\n    name: 'editMode',\n  });\n  this.modeSwitch.enter('display');\n}\n\n\nEditMode.prototype = {\n  className: 'EditMode',\n\n  getConstructorArgs: function() {\n    return {\n      adapter: this.adapter,\n      animator: this.animator,\n      alternateInterval: this.alternateInterval,\n      labelSet: this.labelSet,\n      modeSwitch: this.modeSwitch,\n    };\n  },\n\n  activate: function(node) {\n    LOG.info('activating');\n    this._validate();\n    this.modeSwitch\n      .exit('display')\n      .exit('edit', this._cleanUpEditState.bind(this))\n      .enter('edit', (function() {\n        var otherNodes = this.adapter.getNodes(function(n) {\n          return n.id !== node.id;\n        });\n        var originalColors = otherNodes.reduce(function(accum, node) {\n          accum[node.id] = node.color;\n          return accum;\n        }, {});\n\n        var animation = this._startEditAnimation(otherNodes, originalColors);\n\n        this.labelSet.edit(node);\n\n        var editState = {\n          node: node,\n          animation: animation,\n          otherNodes: otherNodes,\n          originalColors: originalColors,\n        };\n        LOG.debug('activated', editState);\n        return editState;\n      }).bind(this));\n  },\n\n  deactivate: function() {\n    LOG.debug('deactvating');\n    this._validate();\n    this.modeSwitch\n      .exit('edit', this._cleanUpEditState.bind(this))\n      .enter('display', function() {\n        LOG.debug('deactvated');\n      });\n  },\n\n  perform: function(opts) {\n    opts = Object.assign({\n      ifActive: function() {},\n      ifNotActive: function() {},\n    }, opts);\n    this._validate();\n\n    this.modeSwitch.ifActive({\n      edit: function(editState) { opts.ifActive(editState.node); },\n      display: opts.ifNotActive,\n    });\n  },\n\n  _setNeon: function(otherNodes) {\n    otherNodes.forEach((function(n) {\n      this.adapter.setNodeColor(n, colors.NEON);\n    }).bind(this));\n  },\n\n  _setOriginalColors: function(otherNodes, originalColors) {\n    otherNodes.forEach((function(n) {\n      this.adapter.setNodeColor(n, originalColors[n.id]);\n    }).bind(this));\n  },\n\n  _cleanUpEditState: function(editState) {\n    LOG.debug('cleaning up edit mode state', editState);\n    editState.animation.stop();\n    this.labelSet.display(editState.node);\n    this._setOriginalColors(editState.otherNodes, editState.originalColors);\n  },\n\n  _startEditAnimation: function(otherNodes, originalColors) {\n    return this.animator\n    .alternate(\n      this._setNeon.bind(this, otherNodes),\n      this._setOriginalColors.bind(this, otherNodes, originalColors)\n    )\n    .every(this.alternateInterval)\n    .play();\n  },\n\n  _validate: function() {\n    if (!this.adapter) {\n      throw new Error('adapter is required');\n    }\n    if (!this.animator) {\n      throw new Error('animator is required');\n    }\n    if (!this.modeSwitch) {\n      throw new Error('modeSwitch is required');\n    }\n  }\n\n};\n\nmodule.exports = EditMode;\n",
    "var EditMode = require('./EditMode');\nvar Logger = require('../Logger');\n\nvar LOG = new Logger('NonAnimatingEditMode');\n\n\nfunction NonAnimatingEditMode() {\n  EditMode.apply(this, arguments);\n}\n\n\nNonAnimatingEditMode.prototype = Object.assign(new EditMode(), {\n  className: 'NonAnimatingEditMode',\n\n  _startEditAnimation: function() {\n    LOG.debug('not animating for edit mode');\n    return { stop: function() {} };\n  },\n\n  _validate: function() {\n    if (!this.adapter) {\n      throw new Error('adapter is required');\n    }\n    if (!this.modeSwitch) {\n      throw new Error('modeSwitch is required');\n    }\n  },\n});\n\nmodule.exports = NonAnimatingEditMode;\n",
    "var utils = require('../utils');\nvar Literal = require('../utils/Literal');\nvar Logger = require('../Logger');\n\nvar LOG = new Logger('UrlState');\n\nNUM_NODES_PARAM = 'n'\nCOLOR_PARAM_PREFIX = 'c_';\nEDGE_PARAM_PREFIX = 'e_';\nLABEL_PARAM_PREFIX = 'l_';\n\nfunction UrlState(options) {\n  this.baseUrl = (options && options.baseUrl);\n  this.setUrl = (options && options.setUrl);\n  this.urlSearchParams = (options && options.urlSearchParams);\n}\n\nUrlState.prototype = {\n  className: 'UrlState',\n  getConstructorArgs: function() {\n    return {\n      baseUrl: this.baseUrl,\n      setUrl: new Literal('window.history.replaceState.bind(window.history, {}, \\'\\')'),\n      urlSearchParams: new Literal('new URLSearchParams(window.location.search)'),\n    };\n  },\n\n  /**\n   * Perist a node and return its id\n   */\n  persistNode: function(options) {\n    options = options || {};\n    var nodeId;\n    if (options.hasOwnProperty('id') && options.id !== null && options.id !== undefined) {\n      nodeId = options.id;\n    } else {\n      nodeId = this._getNumNodes();\n      this.urlSearchParams.set(NUM_NODES_PARAM, nodeId + 1);\n    }\n\n    if (options.color) {\n      this._setNodeColor(nodeId, options.color);\n    }\n\n    if (options.label) {\n      this._setNodeLabel(nodeId, options.label);\n    }\n\n    this._persistState();\n    return nodeId;\n  },\n\n  retrieveNode: function(nodeId) {\n    var nodeBit = this._idToBit(nodeId);\n    var nodeColor = this._getColorKeys().find((function(param) {\n      return this._isColor({ bit: nodeBit, colorKey: param });\n    }).bind(this));\n    var label = this.urlSearchParams.get(LABEL_PARAM_PREFIX + nodeId);\n    return utils.optional({\n      id: nodeId,\n      color: (nodeColor && nodeColor.replace(COLOR_PARAM_PREFIX, '#')),\n      label: label && decodeURIComponent(label),\n    }, { force: 'id' });\n  },\n\n  persistEdge: function(sourceId, targetId) {\n    var param = EDGE_PARAM_PREFIX + sourceId;\n    var bitmask;\n    if (this.urlSearchParams.has(param)) {\n      bitmask = this._getBitmaskParam(param) | this._idToBit(targetId);\n    } else {\n      bitmask = this._idToBit(targetId);\n    }\n    this._setBitmaskParam(param, bitmask);\n    this._persistState();\n  },\n\n  retrievePersistedNodes: function() {\n    var nodes = [];\n    if (this.urlSearchParams.has(NUM_NODES_PARAM)) {\n      for (var i = 0 ; i < this.urlSearchParams.get(NUM_NODES_PARAM); i++) {\n        nodes.push(this.retrieveNode(i));\n      }\n    }\n    return nodes;\n  },\n\n  retrievePersistedEdges: function() {\n    return this._getEdgeKeys().map((function(key) {\n      var sourceId = parseInt(key.replace(EDGE_PARAM_PREFIX, ''));\n      var edges = [];\n      var bitmask = this._getBitmaskParam(key);\n      var maxId = bitmask.toString(2).length;\n      for (var targetId = 0; targetId < maxId; targetId++) {\n        var bit = this._idToBit(targetId);\n        if ((bitmask & bit) === bit) {\n          edges.push({ source: sourceId, target: targetId });\n        }\n      }\n      return edges;\n    }).bind(this))\n    .reduce(function(a, b) { return a.concat(b); }, []);\n  },\n\n  _setNodeLabel: function(nodeId, label) {\n    this.urlSearchParams.set(\n      LABEL_PARAM_PREFIX + nodeId,\n      encodeURIComponent(label)\n    );\n  },\n\n  getUrl: function() {\n    return this.baseUrl + '?' + this.urlSearchParams.toString();\n  },\n\n  reset: function() {\n    LOG.debug('resetting');\n    this._getKeys().forEach((function(key) {\n      this.urlSearchParams.delete(key);\n    }).bind(this));\n    this._persistState();\n  },\n\n  _isColor: function(options) {\n    options = this._normalizeColorOptions(options);\n\n    if (this.urlSearchParams.has(options.colorKey)) {\n      return (this._getBitmaskParam(options.colorKey) & options.bit) === options.bit;\n    } else {\n      return false;\n    }\n  },\n\n  _setColor: function(options) {\n    options = this._normalizeColorOptions(options);\n    var bitmask;\n\n    if (this.urlSearchParams.has(options.colorKey)) {\n      bitmask = this._getBitmaskParam(options.colorKey) | options.bit;\n    } else {\n      bitmask = options.bit;\n    }\n    this._setBitmaskParam(options.colorKey, bitmask);\n  },\n\n  _removeColor: function(options) {\n    options = this._normalizeColorOptions(options);\n    if (!this.urlSearchParams.has(options.colorKey)) {\n      throw Error('Attempted to remove color ' + options.colorKey);\n    }\n    var bitmask = this._getBitmaskParam(options.colorKey) & (~options.bit);\n    if (bitmask === 0) {\n      this.urlSearchParams.delete(options.colorKey);\n    } else {\n      this._setBitmaskParam(options.colorKey, bitmask);\n    }\n  },\n\n  _getBitmaskParam: function(key) {\n    return parseInt(this.urlSearchParams.get(key), 16);\n  },\n\n  _setBitmaskParam: function(key, value) {\n    this.urlSearchParams.set(key, value.toString(16));\n  },\n\n  _idToBit: function(id) {\n    if (id <= 30) {\n      return 1 << id;\n    } else {\n      return Math.pow(2, id);\n    }\n  },\n\n  _normalizeColorOptions: function(options) {\n    if (!options.hasOwnProperty('bit') && !options.hasOwnProperty('nodeId')) {\n      throw Error('bit or nodeId is required');\n    }\n    if (!options.hasOwnProperty('color') && !options.hasOwnProperty('colorKey')) {\n      throw Error('color or colorKey is required');\n    }\n    var bit = options.hasOwnProperty('bit')\n      ? options.bit\n      : this._idToBit(options.nodeId);\n    var colorKey = options.hasOwnProperty('colorKey')\n      ? options.colorKey\n      : options.color.replace('#', COLOR_PARAM_PREFIX);\n    return { bit: bit, colorKey: colorKey };\n  },\n\n  _getColorKeys: function() {\n    return this._getKeys(function(k) {\n      return k.startsWith(COLOR_PARAM_PREFIX);\n    });\n  },\n\n  _getEdgeKeys: function() {\n    return this._getKeys(function(k) {\n      return k.startsWith(EDGE_PARAM_PREFIX);\n    });\n  },\n\n  _getKeys: function(predicate) {\n    predicate = predicate || function() { return true; };\n    var keys = [];\n    var iterator = this.urlSearchParams.keys();\n    var next = iterator.next();\n    while (!next.done) {\n      if (predicate(next.value)) {\n        keys.push(next.value);\n      }\n      next = iterator.next();\n    }\n    return keys;\n  },\n\n  _getNumNodes: function() {\n    if (this.urlSearchParams.has(NUM_NODES_PARAM)) {\n      return parseInt(this.urlSearchParams.get(NUM_NODES_PARAM));\n    } else {\n      return 0;\n    }\n  },\n\n  _setNodeColor: function(nodeId, color) {\n    var bit = this._idToBit(nodeId);\n\n    this._getColorKeys().forEach((function(key) {\n      if (this._isColor({ bit: bit, colorKey: key })) {\n        this._removeColor({ bit: bit, colorKey: key });\n      }\n    }).bind(this));\n\n    this._setColor({ bit: bit, color: color });\n  },\n\n\n  _persistState: function() {\n    this.setUrl(this.getUrl());\n  },\n};\n\nmodule.exports = UrlState;\n",
    "var Literal = require('./utils/Literal');\n\n/**\n * Compute the cartesian distance between two vectors\n */\nfunction distance(point1, point2) {\n  var x = point1.x - point2.x;\n  var y = point1.y - point2.y;\n  return Math.sqrt(x*x + y*y);\n}\n\n/**\n * Construct an object that has all the key-values for which values\n * are present in the input.\n */\nfunction optional(keyValuePairs, options) {\n  var obj = {};\n  Object.keys(keyValuePairs).forEach(function(key) {\n    if (keyValuePairs[key]) {\n      obj[key] = keyValuePairs[key];\n    }\n  });\n  if (options && options.force) {\n    if (options.force.constructor === Array) {\n      options.force.forEach(function(key) {\n        obj[key] = keyValuePairs[key];\n      });\n    } else {\n      obj[options.force] = keyValuePairs[options.force];\n    }\n  }\n  return obj;\n}\n\n\nfunction normalizeEvent(event) {\n  if (event && event.touches && event.touches.length) {\n    return Object.assign(\n      event,\n      {\n        clientX: event.touches[0].clientX,\n        clientY: event.touches[0].clientY,\n        screenX: event.touches[0].screenX,\n        screenY: event.touches[0].screenY,\n      }\n    );\n  } else {\n    return event;\n  }\n}\n\nfunction isOneValuedObject(obj) {\n  if (obj && (typeof obj === 'object') && !Array.isArray(obj)) {\n    var presentKeys = Object.keys(obj)\n      .filter(function(k) { return !!obj[k]; });\n    return presentKeys.length === 1\n  } else {\n    return false;\n  }\n}\n\nfunction startingAt(array, startingItem) {\n  var startingIndex = array.indexOf(startingItem)\n  if (startingIndex >= 0) {\n    var returnValue = [];\n    for (var i = startingIndex; i < array.length; i++) {\n      returnValue.push(array[i]);\n    }\n    for (var i = 0; i < startingIndex; i++) {\n      returnValue.push(array[i]);\n    }\n    return returnValue;\n  } else {\n    return array;\n  }\n}\n\nfunction requireNonNull(container, property) {\n  if (!container[property]) {\n    throw new Error('missing required property ' + property);\n  }\n  return container[property];\n}\n\nfunction toJs(value, indentLevel) {\n  indentLevel = indentLevel || 0;\n  function indentOutro(line) {\n    return ' '.repeat(indentLevel) + line;\n  }\n  function indentNestedLine(line) {\n    return ' '.repeat(indentLevel + 2) + line;\n  }\n  if (value instanceof Literal) {\n    return value.value;\n  } else if (Array.isArray(value)) {\n    return '[\\n' +\n      value.map(function(a) { return toJs(a, indentLevel + 2) + ','; })\n      .map(indentNestedLine)\n      .join('\\n') +\n      '\\n' +\n      indentOutro(']');\n  } else if (value && value.className && value.getConstructorArgs) {\n    return 'new ' + value.className + '({\\n' +\n      Object.keys(value.getConstructorArgs())\n      .map(function(k) { return k +': ' + toJs(value.getConstructorArgs()[k], indentLevel + 2) + ','; })\n      .map(indentNestedLine)\n      .join('\\n') +\n      '\\n' +\n      indentOutro('})');\n  } else if (value && typeof value === 'object') {\n    return '{\\n' +\n      Object.keys(value).map(function(k) {\n        return k + ': ' + toJs(value[k], indentLevel + 2) + ',';\n      })\n      .map(indentNestedLine)\n      .join('\\n') +\n      '\\n' +\n      indentOutro('}');\n  } else if (value && typeof value === 'string') {\n    return '\\'' + replaceAll(value, \"'\", \"\\\\'\") + '\\'';\n  } else if (value || value === 0) {\n    return value.toString();\n  } else {\n    return 'null';\n  }\n}\n\nfunction replaceAll(str, original, replacement) {\n  return str.split(original).join(replacement);\n}\n\nmodule.exports = {\n  distance: distance,\n  optional: optional,\n  normalizeEvent: normalizeEvent,\n  isOneValuedObject: isOneValuedObject,\n  startingAt: startingAt,\n  toJs: toJs,\n  replaceAll: replaceAll,\n  requireNonNull: requireNonNull,\n};\n",
    "function Literal(value) {\n  this.value = value;\n}\n\nmodule.exports = Literal;\n"
  ]
}